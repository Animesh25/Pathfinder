{"version":3,"sources":["Components/Node.js","algorithms/a_star_search.js","algorithms/dijkstra.js","algorithms/breadth_first.js","algorithms/depth_first.js","algorithms/best_first.js","Helpers/path_finder.js","Components/Dropdown.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","x","y","useEffect","setWall","isWall","setStart","isStart","setEnd","isEnd","setPath","isPath","setVisited","isVisited","useState","className","onMouseDown","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp","handleMouseUp","getNeighbours","node","ROWS","COLS","neighbours","push","distance_from_end","endLoc","Math","abs","contains","discovered_nodes","i","length","remove","list","splice","find_lowest_node","path","slice","min_heuristic","min_distance_to_end","dijkstra_algorithm","startLoc","Grid","visited","unvisited","node_lowest_cost","undefined","console","log","neighbour","cost","update_cost","remove_from_unvisited","previous","found","current","unvisted","min_cost","bfs","removed","queue","head","shift","dfs","stack","best_first","open_nodes","closed_nodes","h_score","last_closed","timeout","delay","Promise","res","setTimeout","find_path_from_closed","a","found_start","last","unshift","draw_path","type","newGrid","Dropdown","setOptions","options","hovered","setHover","mainValue","setMainValue","menuOptions","value","onClick","changeValue","dropDownValueChanged","onMouseLeave","App","setGrid","mouseDown","setMouseDown","setStartLoc","setEndLoc","startDrag","setStartDrag","endDrag","setEndDrag","gridPath","visitedPath","dropDownValue","setDropDownValue","createGrid","grid","dijkstra","clear_visited_path","clear_old_path","draw_path_helper","find_path_from_closed_helper","BFS","best_first_search","DFS","aStarSearch","g_score","f_score","findPath","clearWalls","map","row","yIndex","xIndex","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.87fa6fe2.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport '../CSS/node.css';\r\n\r\nfunction Node(props) {\r\n\r\n  const x = props.x;\r\n  const y = props.y;\r\n\r\n  useEffect(() => {\r\n    setWall(props.isWall) //> I'm dispatching an action here.\r\n    setStart(props.isStart) //> I'm dispatching an action here.\r\n    setEnd(props.isEnd)\r\n    setPath(props.isPath)\r\n    setVisited(props.isVisited)\r\n  }, [props.isWall, props.isStart, props.isEnd,props.isPath,props.isVisited])\r\n\r\n  const [isWall, setWall] = useState(false);\r\n  const [isStart, setStart] = useState(false);\r\n  const [isEnd, setEnd] = useState(false);\r\n  const [isPath, setPath] = useState(false);\r\n  const [isVisited, setVisited] = useState(false);\r\n\r\n\r\n  let className = \"node\";\r\n  if (isEnd === true) {\r\n    className = \"end\";\r\n  }\r\n  else if (isStart === true) {\r\n    className = \"start\";\r\n  }\r\n  else if (isWall === true) {\r\n    className = \"wall\";\r\n  }\r\n  else if (isVisited === true) {\r\n    className = \"visited\";\r\n  }\r\n  else if (isPath === true) {\r\n    className = \"path\";\r\n  }\r\n  else {\r\n    className = \"node\";\r\n  }\r\n\r\n  return (\r\n    <div\r\n      onMouseDown={() => props.handleMouseDown(x, y)}\r\n      onMouseEnter={() => props.handleMouseEnter(x, y)}\r\n      onMouseUp={() => props.handleMouseUp()}\r\n      className={className} />\r\n  );\r\n}\r\n\r\nexport default Node;\r\n","\r\n\r\nexport const findPath = (ROWS, COLS, startLoc, endLoc, Grid) => {\r\n\r\n\r\n    // console.log(\"rows=\",ROWS,\" cols=\",COLS,\" startLoc=\",startLoc,\"  endloc=\",endLoc,\"  grid=\",Grid);\r\n\r\n    let open_nodes = [[startLoc[0], startLoc[1], 0, 0, 0]];\r\n    let closed_nodes = [];\r\n\r\n    while (open_nodes.length > 0 && open_nodes.length < 20000) {\r\n\r\n        const node_lowest_cost = find_lowest_node(open_nodes, closed_nodes);\r\n        if (node_lowest_cost === undefined) break;\r\n\r\n        // console.log(\"lowest=\", node_lowest_cost);\r\n        // console.log(\"chosen from\", open_nodes);\r\n\r\n\r\n        let neighbours = getNeighbours(node_lowest_cost,ROWS,COLS);\r\n        // console.log(\"neighbours================\",neighbours);\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            let g_score, h_score, f_score = 0;\r\n\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall) {\r\n                continue;\r\n                // console.log(\"isWall\")\r\n                // g_score = 10000;\r\n                // h_score = 10000;\r\n                // f_score = g_score + h_score;\r\n            }\r\n            else {\r\n                g_score = node_lowest_cost[2] + 2;\r\n                h_score = distance_from_end(neighbour,endLoc);\r\n                f_score = g_score + h_score;\r\n            }\r\n\r\n\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                closed_nodes.push(node_lowest_cost);\r\n                closed_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n                // console.log(\"end found\");\r\n                break;\r\n            }\r\n\r\n            if (contains(open_nodes, neighbour)) {\r\n                // if (distance_from_start(neighbour) <= f_score) console.log(\"1st if \", neighbour);\r\n            }\r\n            else if (contains(closed_nodes, neighbour)) {\r\n                // console.log(\"neighbour \", neighbour, \" in closed list\");\r\n                // if (distance_from_start(neighbour) <= f_score) console.log(\"2nd if \", neighbour);\r\n                // else {\r\n                // console.log(\"closed_nodes l=\", closed_nodes.length)\r\n                remove(closed_nodes, neighbour);\r\n                // console.log(\"closed_nodes AFTER l=\", closed_nodes.length);\r\n                open_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n                // }\r\n\r\n            }\r\n            else {\r\n                open_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n            }\r\n        }\r\n        if (closed_nodes.length > 0) {\r\n            const last_closed = closed_nodes[closed_nodes.length - 1];\r\n            if (last_closed[0] === endLoc[0] && last_closed[1] === endLoc[1]) {       \r\n                break;\r\n            }\r\n        }\r\n        if (!contains(closed_nodes, node_lowest_cost)) {\r\n            closed_nodes.push(node_lowest_cost);\r\n        }\r\n    }\r\n    return closed_nodes;\r\n\r\n}\r\n\r\n const getNeighbours = (node,ROWS,COLS) => {\r\n    // node=node.value\r\n    // console.log(\"row in get neigbours=\",ROWS);\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    if (node[0] > 0) {\r\n        neighbours.push([node[0] - 1, node[1]]);\r\n        if (node[1] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([node[0], node[1] - 1]);\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([node[0] + 1, node[1]]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] + 1]);\r\n        }\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([node[0], node[1] + 1]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] + 1]);\r\n        }\r\n    }\r\n\r\n    return neighbours;\r\n\r\n}\r\n const distance_from_start = (node,startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\n const distance_from_end = (node,endLoc) => {\r\n    //  console.log(\"distance end====================================\",node,\"  endLoc=\",endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\n const contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n const remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\n const find_lowest_node = (discovered_nodes, path) => {\r\n    const copy = discovered_nodes.slice();\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_heuristic = 10000000;\r\n    let min_distance_to_end = 1000000;\r\n    let node;\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][2] < min_heuristic && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            min_distance_to_end = discovered_nodes[i][3];\r\n            node = discovered_nodes[i];\r\n        }\r\n        else if (discovered_nodes[i][2] === min_heuristic && discovered_nodes[i][3] < min_distance_to_end && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            min_distance_to_end = discovered_nodes[i][3];\r\n            node = discovered_nodes[i];\r\n            // console.log(\"found lowest \", node);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\n","\r\n\r\nexport const dijkstra_algorithm = (ROWS, COLS, startLoc, endLoc, Grid) => {\r\n\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let visited = [];\r\n    let unvisited = [[startLoc[0], startLoc[1], 0, null]];\r\n\r\n\r\n\r\n    while (unvisited.length > 0 && unvisited.length < 20000) {\r\n\r\n        const node_lowest_cost = find_lowest_node(unvisited);\r\n\r\n        if (node_lowest_cost === undefined) { console.log(\"node_lowest=undefined so break\"); break; }\r\n        let neighbours = getNeighbours(node_lowest_cost, visited, ROWS, COLS);\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            \r\n            if (contains(visited, neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall) {\r\n                continue\r\n            }\r\n            else {\r\n                cost = 1 + node_lowest_cost[2];\r\n            }\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                visited.push(node_lowest_cost);\r\n                visited.push([neighbour[0], neighbour[1], cost, node_lowest_cost]);\r\n                // console.log(\"end found\");\r\n                return visited;\r\n            }\r\n            update_cost(neighbour, cost, node_lowest_cost, unvisited);\r\n\r\n        }\r\n        unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n        visited.push(node_lowest_cost);\r\n        // console.log(\"visited=\" + visited);\r\n        // console.log(\"not visited=\" + unvisited);\r\n\r\n\r\n    }\r\n    return visited;\r\n\r\n\r\n}\r\nconst update_cost = (node, cost, previous, unvisited) => {\r\n    let found = false;\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) {\r\n            found = true;\r\n            if (unvisited[2] > cost) {\r\n                unvisited[2] = cost;\r\n                unvisited[3] = previous;\r\n                return unvisited;\r\n            }\r\n        }\r\n    }\r\n    if (!found) unvisited.push([node[0], node[1], cost, previous]);\r\n    return unvisited;\r\n}\r\nconst remove_from_unvisited = (node, unvisited) => {\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) unvisited.splice(i, 1);\r\n    }\r\n    return unvisited;\r\n}\r\n\r\nconst getNeighbours = (node, visited, ROWS, COLS) => {\r\n    // node=node.value\r\n    // console.log(\"row in get neigbours=\", ROWS);\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    if (node[0] > 0) {\r\n        neighbours.push([node[0] - 1, node[1]]);\r\n        if (node[1] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([node[0], node[1] - 1]);\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([node[0] + 1, node[1]]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] + 1]);\r\n        }\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([node[0], node[1] + 1]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] + 1]);\r\n        }\r\n    }\r\n\r\n    return neighbours;\r\n\r\n}\r\nconst distance_from_start = (node, startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\nconst distance_from_end = (node, endLoc) => {\r\n    // console.log(\"distance end====================================\", node, \"  endLoc=\", endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (unvisted) => {\r\n\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_cost = 10000000;\r\n    let node;\r\n    for (let i = 0; i < unvisted.length; i++) {\r\n        if (unvisted[i][2] < min_cost) {\r\n            min_cost = unvisted[i][2];\r\n            node = unvisted[i];\r\n        }\r\n\r\n    }\r\n    return node;\r\n}\r\n\r\n","\r\n\r\nexport const bfs = (ROWS, COLS, startLoc, endLoc, Grid) => {\r\n\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let removed=[];\r\n    let queue = [[startLoc[0], startLoc[1], 0, null]];\r\n    while (queue.length>0) {\r\n\r\n        const head = queue[0];\r\n\r\n        if (head === undefined) { console.log(\"head=undefined so break\"); break; }\r\n        let neighbours = getNeighbours(head, ROWS, COLS);\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            \r\n            if (contains(queue, neighbour) || contains(removed,neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall) {\r\n                continue\r\n            }\r\n            else {\r\n                cost = 1 + head[2];\r\n            }\r\n            queue.push([neighbour[0], neighbour[1], cost, head]);\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                removed.push(queue.shift());\r\n                removed.push([neighbour[0], neighbour[1], cost, head]);\r\n                return removed;\r\n            }  \r\n\r\n        }\r\n        removed.push(queue.shift());\r\n        // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n     \r\n\r\n\r\n    }\r\n    return removed;\r\n\r\n\r\n}\r\nconst update_cost = (node, cost, previous, unvisited) => {\r\n    let found = false;\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) {\r\n            found = true;\r\n            if (unvisited[2] > cost) {\r\n                unvisited[2] = cost;\r\n                unvisited[3] = previous;\r\n                return unvisited;\r\n            }\r\n        }\r\n    }\r\n    if (!found) unvisited.push([node[0], node[1], cost, previous]);\r\n    return unvisited;\r\n}\r\nconst remove_from_unvisited = (node, unvisited) => {\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) unvisited.splice(i, 1);\r\n    }\r\n    return unvisited;\r\n}\r\n\r\nconst getNeighbours = (node, ROWS, COLS) => {\r\n    // node=node.value\r\n    console.log(\"row in get neigbours=\", ROWS);\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    if (node[0] > 0) {\r\n        neighbours.push([node[0] - 1, node[1]]);\r\n        if (node[1] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([node[0], node[1] - 1]);\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([node[0] + 1, node[1]]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] + 1]);\r\n        }\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([node[0], node[1] + 1]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] + 1]);\r\n        }\r\n    }\r\n\r\n    return neighbours;\r\n\r\n}\r\nconst distance_from_start = (node, startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\nconst distance_from_end = (node, endLoc) => {\r\n    console.log(\"distance end====================================\", node, \"  endLoc=\", endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (unvisted) => {\r\n\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_cost = 10000000;\r\n    let node;\r\n    for (let i = 0; i < unvisted.length; i++) {\r\n        if (unvisted[i][2] < min_cost) {\r\n            min_cost = unvisted[i][2];\r\n            node = unvisted[i];\r\n        }\r\n\r\n    }\r\n    return node;\r\n}\r\n\r\n","\r\n\r\nexport const dfs = (ROWS, COLS, startLoc, endLoc, Grid) => {\r\n\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let removed=[];\r\n    let stack = [[startLoc[0], startLoc[1], 0, null]];\r\n    while (stack.length>=0 && stack.length<1000) {\r\n\r\n        const head = stack[stack.length-1];\r\n        console.log(\"stack =\",stack);\r\n        removed.push(head);\r\n        stack.splice(stack.length-1,1);\r\n        if (head === undefined) { console.log(\"head=undefined so break\"); break; }\r\n        let neighbours = getNeighbours(head, ROWS, COLS);\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            //if node already in stack, then remove it and push it to the back\r\n            if (contains(removed,neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall) {\r\n                continue\r\n            }\r\n            else {\r\n                cost = 1 + head[2];\r\n            }\r\n            stack.push([neighbour[0], neighbour[1], cost, head]);\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                removed.push(head);\r\n                removed.push([neighbour[0], neighbour[1], cost, head]);\r\n                return removed;\r\n            }  \r\n\r\n        }\r\n        \r\n        // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n     \r\n\r\n\r\n    }\r\n    return removed;\r\n\r\n\r\n}\r\nconst update_cost = (node, cost, previous, unvisited) => {\r\n    let found = false;\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) {\r\n            found = true;\r\n            if (unvisited[2] > cost) {\r\n                unvisited[2] = cost;\r\n                unvisited[3] = previous;\r\n                return unvisited;\r\n            }\r\n        }\r\n    }\r\n    if (!found) unvisited.push([node[0], node[1], cost, previous]);\r\n    return unvisited;\r\n}\r\nconst remove_from_unvisited = (node, unvisited) => {\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) unvisited.splice(i, 1);\r\n    }\r\n    return unvisited;\r\n}\r\n\r\nconst getNeighbours = (node, ROWS, COLS) => {\r\n    // node=node.value\r\n    console.log(\"row in get neigbours=\", ROWS);\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    //TOP\r\n    if (node[0] > 0) {\r\n        neighbours.push([node[0] - 1, node[1]]);\r\n        //Top Left\r\n        if (node[1] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] - 1]);\r\n        }\r\n    }\r\n    //LEFT\r\n    if (node[1] > 0) {\r\n        neighbours.push([node[0], node[1] - 1]);\r\n        //Bottom Left\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] - 1]);\r\n        }\r\n    }\r\n    //BOTTOM\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([node[0] + 1, node[1]]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] + 1]);\r\n        }\r\n    }\r\n    //RIGHT\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([node[0], node[1] + 1]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] + 1]);\r\n        }\r\n    }\r\n    //[top,left,bottom,right]\r\n    console.log(\"neibours of:\",node,\"   =\",neighbours);\r\n    return neighbours;\r\n\r\n}\r\nconst distance_from_start = (node, startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\nconst distance_from_end = (node, endLoc) => {\r\n    console.log(\"distance end====================================\", node, \"  endLoc=\", endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (unvisted) => {\r\n\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_cost = 10000000;\r\n    let node;\r\n    for (let i = 0; i < unvisted.length; i++) {\r\n        if (unvisted[i][2] < min_cost) {\r\n            min_cost = unvisted[i][2];\r\n            node = unvisted[i];\r\n        }\r\n\r\n    }\r\n    return node;\r\n}\r\n\r\n","\r\n\r\nexport const best_first = (ROWS, COLS, startLoc, endLoc, Grid) => {\r\n\r\n\r\n    console.log(\"rows=\",ROWS,\" cols=\",COLS,\" startLoc=\",startLoc,\"  endloc=\",endLoc,\"  grid=\",Grid);\r\n\r\n    let open_nodes = [[startLoc[0], startLoc[1], 0, 0, 0]];\r\n    let closed_nodes = [];\r\n\r\n    while (open_nodes.length > 0 && open_nodes.length < 20000) {\r\n        const node_lowest_cost = find_lowest_node(open_nodes, closed_nodes);\r\n        if (node_lowest_cost === undefined) break;\r\n\r\n        // console.log(\"lowest=\", node_lowest_cost);\r\n        // console.log(\"chosen from\", open_nodes);\r\n\r\n\r\n        let neighbours = getNeighbours(node_lowest_cost,ROWS,COLS);\r\n        console.log(\"neighbours================\",neighbours);\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            let h_score= 0;\r\n\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall) {\r\n                continue;\r\n            }\r\n            else {\r\n                h_score = distance_from_end(neighbour,endLoc);\r\n            }\r\n\r\n\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                closed_nodes.push(node_lowest_cost);\r\n                closed_nodes.push([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n                // console.log(\"end found\");\r\n                break;\r\n            }\r\n\r\n            if (contains(open_nodes, neighbour)) {\r\n                // if (distance_from_start(neighbour) <= f_score) console.log(\"1st if \", neighbour);\r\n            }\r\n            else if (contains(closed_nodes, neighbour)) {\r\n                // console.log(\"neighbour \", neighbour, \" in closed list\");\r\n                // if (distance_from_start(neighbour) <= f_score) console.log(\"2nd if \", neighbour);\r\n                // else {\r\n                // console.log(\"closed_nodes l=\", closed_nodes.length)\r\n                remove(closed_nodes, neighbour);\r\n                // console.log(\"closed_nodes AFTER l=\", closed_nodes.length);\r\n                open_nodes.push([neighbour[0], neighbour[1],h_score, node_lowest_cost]);\r\n                // }\r\n\r\n            }\r\n            else {\r\n                open_nodes.push([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n            }\r\n        }\r\n        if (closed_nodes.length > 0) {\r\n            const last_closed = closed_nodes[closed_nodes.length - 1];\r\n            if (last_closed[0] === endLoc[0] && last_closed[1] === endLoc[1]) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!contains(closed_nodes, node_lowest_cost)) {\r\n            closed_nodes.push(node_lowest_cost);\r\n        }\r\n\r\n        // remove(open_nodes, node_lowest_cost);\r\n        // console.log(\"dn=\", open_nodes);\r\n\r\n\r\n        // break\r\n    }\r\n    // console.log(\"path=\", closed_nodes);\r\n\r\n    return closed_nodes;\r\n\r\n}\r\n\r\n const getNeighbours = (node,ROWS,COLS) => {\r\n    // node=node.value\r\n    console.log(\"row in get neigbours=\",ROWS);\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    if (node[0] > 0) {\r\n        neighbours.push([node[0] - 1, node[1]]);\r\n        if (node[1] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([node[0], node[1] - 1]);\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] - 1]);\r\n        }\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([node[0] + 1, node[1]]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([node[0] + 1, node[1] + 1]);\r\n        }\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([node[0], node[1] + 1]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([node[0] - 1, node[1] + 1]);\r\n        }\r\n    }\r\n\r\n    return neighbours;\r\n\r\n}\r\n const distance_from_start = (node,startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\n const distance_from_end = (node,endLoc) => {\r\n     console.log(\"distance end====================================\",node,\"  endLoc=\",endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\n const contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n const remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\n const find_lowest_node = (discovered_nodes, path) => {\r\n    const copy = discovered_nodes.slice();\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_heuristic = 10000000;\r\n    let node;\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][2] < min_heuristic && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            node = discovered_nodes[i];\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\n","import Node from '../Components/Node';\r\n\r\nexport function timeout(delay) {\r\n    return new Promise(res => setTimeout(res, delay));\r\n}\r\n\r\nexport const find_path_from_closed = async (closed_nodes, startLoc) => {\r\n    let path = [];\r\n    let found_start = false;\r\n    let last = closed_nodes[closed_nodes.length - 1];\r\n    while (found_start === false) {\r\n        path.unshift(last);\r\n        if (last === undefined) break;\r\n        if (last[0] === startLoc[0] && last[1] === startLoc[1]) found_start = true;\r\n        else {\r\n            last = last[last.length - 1];\r\n        }\r\n    }\r\n    return path;\r\n}\r\nexport const draw_path = async (Grid, path, i, type) => {\r\n    const newGrid = Grid.slice();\r\n    if (i > 0 && i < path.length - 1) {\r\n        const x = path[i][0];\r\n        const y = path[i][1]\r\n        // console.log(\"node=\", x, y);\r\n        // console.log(newGrid[x][y])\r\n        if (type === \"visited\") {\r\n            newGrid[x][y] = <Node\r\n                isWall={false}\r\n                isStart={Grid[x][y].props.isStart}\r\n                isEnd={Grid[x][y].props.isEnd}\r\n                isPath={false}\r\n                isVisited={true}\r\n            />;\r\n        }\r\n        else {\r\n            newGrid[x][y] = <Node\r\n                isWall={false}\r\n                isStart={Grid[x][y].props.isStart}\r\n                isEnd={Grid[x][y].props.isEnd}\r\n                isPath={true}\r\n                isVisited={false}\r\n            />;\r\n        }\r\n    }\r\n    return newGrid;\r\n\r\n\r\n}","import React, { useState, useEffect } from 'react';\r\nimport '../CSS/dropdown.css';\r\n\r\nfunction Dropdown(props) {\r\n    useEffect(() => {\r\n        setOptions(props.options) //> I'm dispatching an action here.\r\n    }, [props.options])\r\n\r\n    const [options, setOptions] = useState([]);\r\n    const [hovered, setHover] = useState(false);\r\n    const [mainValue, setMainValue] = useState(\"Search Algorithm\");\r\n\r\n    let menuOptions=[];\r\n    for(const value of options){\r\n        menuOptions.push(<p onClick={()=>changeValue(value)} className={\"item\"}>{value}</p>)\r\n    }\r\n    \r\n    const changeValue=(value)=>{\r\n        setMainValue(value);\r\n        props.dropDownValueChanged(value);\r\n    }\r\n\r\n    return (\r\n        <div className={\"dropdownContainer\"}  onMouseEnter={() => setHover(true)} onMouseLeave={() => setHover(false)} >\r\n            <div className={\"dropdown\"}>\r\n                <p className={\"value\"}>{mainValue}</p>\r\n            </div>\r\n            {hovered && (\r\n                <div className={\"subMenu\"}>\r\n                    {menuOptions}\r\n                </div>\r\n            )}\r\n        </div>\r\n\r\n    )\r\n}\r\nexport default Dropdown;","import React, { useState, useEffect } from 'react';\n\nimport './CSS/grid.css';\nimport Node from './Components/Node';\nimport { findPath } from './algorithms/a_star_search';\nimport { dijkstra_algorithm } from './algorithms/dijkstra';\nimport { bfs } from './algorithms/breadth_first';\nimport { dfs } from './algorithms/depth_first';\nimport { best_first } from './algorithms/best_first';\nimport { timeout, find_path_from_closed, draw_path } from './Helpers/path_finder';\nimport Dropdown from './Components/Dropdown';\n\n\n\nfunction App() {\n\n  const [Grid, setGrid] = useState([]);\n  const [mouseDown, setMouseDown] = useState(false);\n  const [startLoc, setStartLoc] = useState([5, 5]);\n  const [endLoc, setEndLoc] = useState([5, 15]);\n  const [startDrag, setStartDrag] = useState(false);\n  const [endDrag, setEndDrag] = useState(false);\n  const [gridPath, setPath] = useState([]);\n  const [visitedPath, setVisited] = useState([]);\n  const [dropDownValue, setDropDownValue] = useState(\"\");\n  \n\n  useEffect(() => {\n    setGrid(createGrid());\n\n  }, []);\n\n  const ROWS = 15;\n  const COLS = 30;\n\n  const createGrid = () => {\n\n    let grid = [];\n    for (let y = 0; y < ROWS; y++) {\n      grid.push([]);\n      for (let x = 0; x < COLS; x++) {\n        grid[y].push(\n          <Node\n            handleMouseDown={() => handleMouseDown(x, y)}\n            handleMouseEnter={() => handleMouseEnter(x, y)}\n            handleMouseUp={() => handleMouseUp()}\n            isWall={false} />\n        );\n      }\n    }\n    grid[startLoc[0]][startLoc[1]] = <Node\n      isWall={false}\n      isStart={true}\n      isEnd={false}\n      isPath={false}\n      isVisited={false}\n      handleMouseDown={() => handleMouseDown(startLoc[0], startLoc[1])}\n      handleMouseEnter={() => handleMouseEnter(startLoc[0], startLoc[1])}\n      handleMouseUp={() => handleMouseUp(startLoc[0], startLoc[1])}\n    />;\n    grid[endLoc[0]][endLoc[1]] = <Node\n      isWall={false}\n      isStart={false}\n      isPath={false}\n      isVisited={false}\n      isEnd={true}\n      handleMouseDown={() => handleMouseDown(endLoc[0], endLoc[1])}\n      handleMouseEnter={() => handleMouseEnter(endLoc[0], endLoc[1])}\n      handleMouseUp={() => handleMouseUp(endLoc[0], endLoc[1])}\n    />;\n\n    return grid;\n  }\n\n\n  const handleMouseDown = (x, y) => {\n    if (x === null || y === null || x < 0 || y < 0) return;\n    // console.log(\"mouse down at\", x, \",\", y);\n    setMouseDown(true);\n    console.log(\"start drag-------------x,y=\", x, \",\", y);\n    console.log(\"start drag-------------startLoc0,startLoc1=\", startLoc[0], \",\", startLoc[1]);\n    if (x == startLoc[0] && y == startLoc[1]) {\n      setStartDrag(true);\n    }\n    else if (x == endLoc[0] && y == endLoc[1]) {\n      setEndDrag(true);\n    }\n    else {\n      // else setStartDrag(false);\n      let newGrid = Grid.slice();\n      if (newGrid[x][y].props.isStart || newGrid[x][y].props.isEnd) return;\n      // console.log(\"boolean=\", newGrid[x][y].props.isWall)\n      newGrid[x][y] =\n        <Node\n          key={y}\n          handleMouseDown={() => handleMouseDown(x, y)}\n          handleMouseEnter={() => handleMouseEnter(x, y)}\n          handleMouseUp={() => handleMouseUp(x, y)}\n          isWall={!newGrid[x][y].props.isWall} />\n\n      // console.log(\"new grid[\", x, \"][\", y, \"]=\", newGrid[x][y])\n      setGrid(newGrid)\n    }\n\n  }\n\n  //if moving start or end we want to retain previous wall position\n  /**\n   * oldGrid=grid\n   * if(start or end)\n   *    \n   */\n  const handleMouseEnter = (x, y) => {\n    if (x === null || y === null || x < 0 || y < 0) return;\n    if (x === endLoc[0] && y === endLoc[1]) return;\n    if (x === startLoc[0] && y === startLoc[1]) return;\n    if (mouseDown) {\n      let newGrid = Grid.slice();\n      if (!startDrag && !endDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            handleMouseDown={() => handleMouseDown(x, y)}\n            handleMouseEnter={() => handleMouseEnter(x, y)}\n            handleMouseUp={() => handleMouseUp(x, y)}\n            isStart={false}\n            isPath={false}\n            isVisited={false}\n            isWall={!newGrid[x][y].props.isWall} />\n      }\n      if (startDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            handleMouseDown={() => handleMouseDown(x, y)}\n            handleMouseEnter={() => handleMouseEnter(x, y)}\n            handleMouseUp={() => handleMouseUp(x, y)}\n            isStart={true}\n            isWall={newGrid[x][y].props.isWall} />\n        newGrid[startLoc[0]][startLoc[1]] = <Node\n          isWall={newGrid[startLoc[0]][startLoc[1]].props.isWall}\n          isStart={false}\n          isEnd={false}\n          isPath={false}\n          isVisited={false}\n          handleMouseDown={() => handleMouseDown(x, y)}\n          handleMouseEnter={() => handleMouseEnter(x, y)}\n          handleMouseUp={() => handleMouseUp(x, y)}\n        />;\n        setStartLoc([x, y])\n      }\n      else if (endDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            handleMouseDown={() => handleMouseDown(x, y)}\n            handleMouseEnter={() => handleMouseEnter(x, y)}\n            handleMouseUp={() => handleMouseUp(x, y)}\n            isStart={false}\n            isEnd={true}\n            isWall={newGrid[x][y].props.isWall}\n            isPath={false}\n            isVisited={false} />\n        newGrid[endLoc[0]][endLoc[1]] = <Node\n          isWall={newGrid[endLoc[0]][endLoc[1]].props.isWall}\n          isStart={false}\n          isEnd={false}\n          isPath={false}\n          isVisited={false}\n          handleMouseDown={() => handleMouseDown(x, y)}\n          handleMouseEnter={() => handleMouseEnter(x, y)}\n          handleMouseUp={() => handleMouseUp(x, y)}\n        />;\n        console.log(\"set wall at endloc=\", endLoc);\n        setEndLoc([x, y])\n\n        console.log(\"new endloc=\", endLoc)\n      }\n      setGrid(newGrid)\n    }\n\n\n\n  }\n  const handleMouseUp = (x, y) => {\n    if (x === null || y === null || x < 0 || y < 0) return;\n    setMouseDown(false);\n    if (startDrag) {\n      setStart(x, y)\n    }\n    else if (endDrag) {\n      // setEnd(x,y);\n    }\n    setStartDrag(false);\n    setEndDrag(false);\n  }\n  const dijkstra = async () => {\n    let closed_nodes = dijkstra_algorithm(ROWS, COLS, startLoc, endLoc, Grid);\n\n    clear_visited_path();\n    clear_old_path(gridPath);\n    setVisited(closed_nodes);\n    await draw_path_helper(closed_nodes, 1, \"visited\");\n    await find_path_from_closed_helper(closed_nodes);\n  }\n  const BFS = async () => {\n    let closed_nodes = bfs(ROWS, COLS, startLoc, endLoc, Grid);\n    // console.log(\"BFS closed=\", closed_nodes);\n    clear_visited_path();\n    clear_old_path(gridPath);\n    setVisited(closed_nodes);\n    await draw_path_helper(closed_nodes, 1, \"visited\");\n    await find_path_from_closed_helper(closed_nodes);\n  }\n\n  const best_first_search = async () => {\n    let closed_nodes = best_first(ROWS, COLS, startLoc, endLoc, Grid);\n    clear_visited_path();\n    clear_old_path(gridPath);\n    setVisited(closed_nodes);\n    // console.log(\"length=\", closed_nodes.length);\n    await draw_path_helper(closed_nodes, 1, \"visited\");\n    await find_path_from_closed_helper(closed_nodes);\n  }\n  const DFS = async () => {\n    let closed_nodes = dfs(ROWS, COLS, startLoc, endLoc, Grid);\n    clear_visited_path();\n    clear_old_path(gridPath);\n    setVisited(closed_nodes);\n    // console.log(\"length=\", closed_nodes.length);\n    await draw_path_helper(closed_nodes, 1, \"visited\");\n    await draw_path_helper(closed_nodes, 1, \"path\");\n  }\n  const aStarSearch = () => {\n    clear_visited_path();\n    clear_old_path(gridPath);\n    let closed_nodes = findPath(ROWS, COLS, startLoc, endLoc, Grid);\n    find_path_from_closed_helper(closed_nodes);\n  }\n  const find_path_from_closed_helper = async (closed_nodes) => {\n    let path = await find_path_from_closed(closed_nodes, startLoc);;\n    setPath(path);\n    // console.log(\"path==================\", path);\n    await draw_path_helper(path, 1, \"path\");\n  }\n  const clear_visited_path = () => {\n    const newGrid = Grid.slice();\n    for (let i = 1; i < visitedPath.length - 1; i++) {\n      const x = visitedPath[i][0];\n      const y = visitedPath[i][1]\n      newGrid[x][y] = <Node\n        isWall={Grid[x][y].props.isWall}\n        isStart={Grid[x][y].props.isStart}\n        isEnd={Grid[x][y].props.isEnd}\n        isPath={false}\n        isVisited={false}\n      />;\n    }\n    setGrid(newGrid);\n  }\n  const clear_old_path = (path) => {\n    const newGrid = Grid.slice();\n\n    for (let i = 1; i < path.length - 1; i++) {\n      const x = path[i][0];\n      const y = path[i][1]\n      newGrid[x][y] = <Node\n        isWall={Grid[x][y].props.isWall}\n        isStart={Grid[x][y].props.isStart}\n        isEnd={Grid[x][y].props.isEnd}\n        isPath={false}\n        isVisited={false}\n\n      />;\n    }\n    setGrid(newGrid);\n  }\n\n\n  const draw_path_helper = async (path, i, type) => {\n    if (i > 0 && i < path.length - 1) {\n      let newGrid = await draw_path(Grid, path, i, type)\n      setGrid(newGrid);\n      await timeout(5);\n      await draw_path_helper(path, i + 1, type);\n    }\n  }\n\n\n\n\n\n  const setStart = (x, y) => {\n    const newGrid = Grid.slice();// doing a deep copy of the array\n    newGrid[startLoc[0]][startLoc[1]] = <Node\n      isWall={false}\n      isStart={true}\n      isEnd={false}\n      isPath={false}\n      isVisited={false}\n      handleMouseDown={() => handleMouseDown(x, y)}\n      handleMouseEnter={() => handleMouseEnter(x, y)}\n      handleMouseUp={() => handleMouseUp(x, y)}\n    />;\n    newGrid[endLoc[0]][endLoc[1]] = <Node\n      isWall={false}\n      isStart={false}\n      isPath={false}\n      isVisited={false}\n      isEnd={true}\n      handleMouseDown={() => handleMouseDown(x, y)}\n      handleMouseEnter={() => handleMouseEnter(x, y)}\n      handleMouseUp={() => handleMouseUp(x, y)}\n    />;\n    setGrid(newGrid);\n\n  }\n  const clearWalls = () => {\n    let grid = [];\n    for (let y = 0; y < ROWS; y++) {\n      grid.push([]);\n      for (let x = 0; x < COLS; x++) {\n        grid[y].push(\n          <Node\n            handleMouseDown={() => handleMouseDown(x, y)}\n            handleMouseEnter={() => handleMouseEnter(x, y)}\n            handleMouseUp={() => handleMouseUp(x, y)}\n            isWall={false}\n            isPath={false}\n            isVisited={false}\n            isStart={Grid[y][x].props.isStart}\n            isEnd={Grid[y][x].props.isEnd} />\n        );\n      }\n    }\n    setGrid(grid);\n  }\n  const options = [\n    'A* star', 'Dijkstra', 'Depth-First Search', 'Breadth-First Search', 'Best-First Search'\n  ];\n  const startAlgorithm=()=>{\n    if(dropDownValue===\"A* star\"){\n      aStarSearch()\n    }\n    else if(dropDownValue===\"Dijkstra\"){\n      dijkstra()\n    }\n    else if(dropDownValue===\"Breadth-First Search\"){\n      BFS()\n    }\n    else if(dropDownValue===\"Depth-First Search\"){\n      DFS()\n    }\n    else if(dropDownValue===\"Best-First Search\"){\n      best_first_search();\n    }\n  }\n  const defaultOption = options[0];\n  \n  \n  \n  return (\n    <div className=\"App\">\n      <div className=\"buttonGroup\">\n        <Dropdown options={options} \n          dropDownValueChanged={(value)=>setDropDownValue(value)} \n        />\n\n        <button className=\"button\" onClick={() => clearWalls()}>Clear Walls</button>\n        {/* <button className=\"button\" onClick={() => aStarSearch()}>A* search</button>\n        <button className=\"button\" onClick={() => dijkstra()}>Dijkstra</button>\n        <button className=\"button\" onClick={() => BFS()}>BFS</button>\n        <button className=\"button\" onClick={() => DFS()}>DFS</button>\n        <button className=\"button\" onClick={() => best_first_search()}>Best First Search</button> */}\n        <button className=\"startButton\" onClick={() =>startAlgorithm()}>Start {dropDownValue}</button>\n      </div>\n      <div className=\"container\">\n        {Grid.map((row, yIndex) => {\n          return (\n            <div key={yIndex} className={\"row\"}>\n              {row.map((node, xIndex) => {\n                return (\n                  <Node\n                    key={xIndex}\n                    isWall={node.props.isWall}\n                    isEnd={node.props.isEnd}\n                    isPath={node.props.isPath}\n                    isVisited={node.props.isVisited}\n                    isStart={node.props.isStart}\n                    handleMouseDown={() => handleMouseDown(yIndex, xIndex)}\n                    handleMouseEnter={() => handleMouseEnter(yIndex, xIndex)}\n                    handleMouseUp={() => handleMouseUp(yIndex, xIndex)}\n                  />\n                )\n\n              })}\n            </div>\n          )\n\n        })}\n\n        <div className=\"keySet\">\n          <div className=\"key\">\n            <Node\n              key={-1}\n              isWall={true}\n              isEnd={false}\n              isPath={false}\n              isVisited={false}\n              isStart={false}\n              handleMouseDown={() => handleMouseDown(-1, -1)}\n              handleMouseEnter={() => handleMouseEnter(-1, -1)}\n              handleMouseUp={() => handleMouseUp(-1, -1)}\n            />\n            <h3>Wall</h3>\n          </div>\n          <div className=\"key\">\n            <Node\n              key={-1}\n              isWall={false}\n              isEnd={false}\n              isPath={false}\n              isVisited={false}\n              isStart={true}\n              handleMouseDown={() => handleMouseDown(-1, -1)}\n              handleMouseEnter={() => handleMouseEnter(-1, -1)}\n              handleMouseUp={() => handleMouseUp(-1, -1)}\n            />\n            <h3>Start</h3>\n          </div>\n          <div className=\"key\">\n            <Node\n              key={-1}\n              isWall={false}\n              isEnd={true}\n              isPath={false}\n              isVisited={false}\n              isStart={false}\n              handleMouseDown={() => handleMouseDown(-1, -1)}\n              handleMouseEnter={() => handleMouseEnter(-1, -1)}\n              handleMouseUp={() => handleMouseUp(-1, -1)}\n            />\n            <h3>End</h3>\n          </div>\n          <div className=\"key\">\n            <Node\n              key={-1}\n              isWall={false}\n              isEnd={false}\n              isPath={false}\n              isVisited={true}\n              isStart={false}\n              handleMouseDown={() => handleMouseDown(-1, -1)}\n              handleMouseEnter={() => handleMouseEnter(-1, -1)}\n              handleMouseUp={() => handleMouseUp(-1, -1)}\n            />\n            <h3>Visited</h3>\n          </div>\n          <div className=\"key\">\n            <Node\n              key={-1}\n              isWall={false}\n              isEnd={false}\n              isPath={true}\n              isVisited={false}\n              isStart={false}\n              handleMouseDown={() => handleMouseDown(-1, -1)}\n              handleMouseEnter={() => handleMouseEnter(-1, -1)}\n              handleMouseUp={() => handleMouseUp(-1, -1)}\n            />\n            <h3>Path</h3>\n          </div>\n\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}