{"version":3,"sources":["Components/Node.js","algorithms/bidirectional_search.js","algorithms/common_methods/methods.js","Components/binaryHeap.js","algorithms/a_star_search.js","algorithms/dijkstra.js","algorithms/breadth_first.js","algorithms/depth_first.js","algorithms/best_first.js","Helpers/path_finder.js","Components/Dropdown.js","Helpers/maze_creation.js","Components/ColourCode.js","Components/Results.js","Helpers/gridMethods.js","Components/dropdownOptions.js","CSS/bomb.svg","App.js","reportWebVitals.js","index.js"],"names":["Node","intersect","props","x","y","useEffect","setWall","isWall","setStart","isStart","setEnd","isEnd","setPath","isPath","setVisited","isVisited","setBomb","isBomb","useState","className","undefined","handleMouseEnter","onMouseDown","handleMouseDown","onMouseEnter","onMouseUp","handleMouseUp","getEightNeighbours","node","ROWS","COLS","neighbours","push","getFourNeighbours","BinaryHeap","this","values","length","element","index","current","parentIndex","Math","floor","parent","i","splice","min","end","pop","leftChildIndex","rightChildIndex","leftChild","rightChild","temp","leftPriority","rightPriority","currentPriority","a_star_search","startLoc","endLoc","Grid","chosenDirection","console","log","open_nodes","add","closed_nodes","node_lowest_cost","removeMin","indexOf","neighbour","isDiagonal","g_score","h_score","f_score","parent_g_cost","distance_from_end","contains","get","remove","abs","discovered_nodes","dijkstra_algorithm","visited","unvisited","cost","update_cost","previous","visitedNode","bfs","removed","queue","head","shift","dfs","stack","best_first","visitedNeighbour","sqrt","bidirectional","startResult","endResult","start_queue","end_queue","updateStart","update_queue","updateEnd","timeout","delay","Promise","res","setTimeout","findPathFromClosed","a","path","found_start","last","unshift","findPathBidirectional","targetNode","intersectOne","one","backTrack","two","concat","list","iterator","drawPath","type","newGrid","slice","Dropdown","setOptions","options","hovered","setHover","default","mainValue","setMainValue","menuOptions","value","onClick","changeValue","dropDownValueChanged","onMouseLeave","setChosenMap","choice","toLowerCase","loopMap","maze_1","maze_2","boxes","smallBoxed","ColourCode","Results","content","setBody","body","chosenAlgorithm","timeTaken","round","performance","now","startTime","expanded","split","map","line","algorithmOptions","directionOptions","mazeOptions","speedOptions","App","setGrid","setStartLoc","setEndLoc","MouseDown","setMouseDown","bombDrag","setBombDrag","startDrag","setStartDrag","endDrag","setEndDrag","isRunning","setRunning","speed","setSpeed","gridPath","visitedPath","setAlgorithm","setDirection","setStartTime","bombLoc","setBombLoc","createGrid","grid","bidirectional_search","biOutput","startToBomb","bombToEnd","firstHalf","firstIntersect","secondHalf","secondHalfIntersect","visitedNodes","stepsBeforeExecution","drawPathHelper","biPathOne","biPathTwo","joined","biPath","clear_visited_path","clear_old_path","stepsAfterExecution","checkEndLocExists","lastElement","findPathFromClosedHelper","startAlgorithm","firstList","secondList","createWalls","chosenMap","j","makeMaze","emptyGrid","clearWalls","removeBomb","src","bombSVG","alt","setting","arr","give2dArray","row","yIndex","xIndex","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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G,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAGjKC,EAAS,CACX,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEjKF,EAAU,CACZ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAGjKG,EAAQ,CACV,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEjKC,EAAa,CACf,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG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","file":"static/js/main.aca36020.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport '../CSS/node.css';\r\n\r\nfunction Node(props) {\r\n\r\n  const x = props.x;\r\n  const y = props.y;\r\n\r\n  useEffect(() => {\r\n    setWall(props.isWall) //> I'm dispatching an action here.\r\n    setStart(props.isStart) //> I'm dispatching an action here.\r\n    setEnd(props.isEnd)\r\n    setPath(props.isPath)\r\n    setVisited(props.isVisited)\r\n    setBomb(props.isBomb)\r\n  }, [props.isWall, props.isStart, props.isEnd, props.isPath, props.isVisited, props.isBomb])\r\n\r\n  const [isWall, setWall] = useState(false);\r\n  const [isStart, setStart] = useState(false);\r\n  const [isEnd, setEnd] = useState(false);\r\n  const [isPath, setPath] = useState(false);\r\n  const [isVisited, setVisited] = useState(false);\r\n  const [isBomb, setBomb] = useState(false);\r\n\r\n\r\n  let className = \"node\";\r\n  if (isEnd === true) {\r\n    className = \"end\";\r\n  }\r\n  else if (isStart === true) {\r\n    className = \"start\";\r\n  }\r\n  else if (isBomb === true) {\r\n    className = \"bomb\";\r\n  }\r\n  else if (isWall === true) {\r\n    className = \"wall\";\r\n  }\r\n  else if (isVisited === true) {\r\n    className = \"visited\";\r\n  }\r\n  else if (isPath === true) {\r\n    className = \"path\";\r\n  }\r\n  else {\r\n    className = \"node\";\r\n  }\r\n\r\n  let mainBody = <div className={className} />;\r\n  if (props.handleMouseEnter === undefined) {\r\n    mainBody = <div className={className} />\r\n  }\r\n  else {\r\n    mainBody = <div\r\n      onMouseDown={() => props.handleMouseDown(x, y)}\r\n      onMouseEnter={() => props.handleMouseEnter(x, y)}\r\n      onMouseUp={() => props.handleMouseUp()}\r\n      className={className} />\r\n  }\r\n  return (\r\n    mainBody\r\n  );\r\n}\r\n\r\nexport default Node;\r\n","import { getFourNeighbours, getEightNeighbours } from './common_methods/methods';\r\n\r\nlet removed = [];\r\nlet intersect;\r\nexport const bidirectional = (ROWS, COLS, startLoc, endLoc, Grid, chosenDirection) => {\r\n    removed=[];\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    \r\n    let start_queue = [[startLoc[0], startLoc[1], 0, null]];\r\n    let end_queue = [[endLoc[0], endLoc[1], 0, null]];\r\n    let startResult,endResult\r\n\r\n    while (start_queue.length > 0) {\r\n\r\n        const updateStart=update_queue(start_queue,ROWS,COLS,Grid,chosenDirection);\r\n        start_queue=updateStart[0];\r\n        startResult=updateStart[1];\r\n\r\n        const updateEnd=update_queue(end_queue,ROWS,COLS,Grid,chosenDirection);\r\n        end_queue=updateEnd[0];\r\n        endResult=updateEnd[1];\r\n                \r\n        if(startResult || endResult){\r\n            // console.log(\"removed before=\", [removed,(intersect[0],intersect[1])]);\r\n            return [removed,intersect];\r\n        } \r\n        \r\n    }\r\n    \r\n    return [removed,intersect];\r\n\r\n\r\n}\r\n\r\nconst update_queue = (queue,ROWS,COLS,Grid,chosenDirection) => {\r\n    const head = queue[0];\r\n    if (head === undefined) { console.log(\"head=undefined so break\"); queue.shift(); return queue }\r\n    \r\n    if(contains(removed,head)){\r\n        intersect=head;\r\n        // console.log(\"head=\",head,\"  in queue\");\r\n        removed.push(head);\r\n        return [queue,true]\r\n    } \r\n    \r\n    let neighbours;\r\n    if (chosenDirection.indexOf(\"4\") > -1) {\r\n        neighbours = getFourNeighbours(head, ROWS, COLS);\r\n    }\r\n    else {\r\n        neighbours = getEightNeighbours(head, ROWS, COLS);\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n        const neighbour = neighbours[i][0];\r\n        const isDiagonal = neighbours[i][1];\r\n\r\n        if (contains(queue, neighbour) || contains(removed, neighbour)) continue;\r\n        let cost = 0;\r\n        if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n            // console.log(\"---------------------------------------\")\r\n            continue\r\n        }\r\n        else {\r\n            if (isDiagonal) cost = 1.41 + head[2];\r\n            else cost = 1 + head[2];\r\n        }\r\n        queue.push([neighbour[0], neighbour[1], cost, head]);\r\n        // if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n        //     removed.push(queue.shift());\r\n        //     removed.push([neighbour[0], neighbour[1], cost, head]);\r\n        //     return removed;\r\n        // }\r\n\r\n    }\r\n    removed.push(queue.shift());\r\n    return [queue,false];\r\n    // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n\r\n}\r\n\r\n\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n\r\n","export const getEightNeighbours = (node, ROWS, COLS) => {\r\n    // node=node.value\r\n    // console.log(\"8 neighbours\");\r\n    let neighbours = [];\r\n    // console.log(\"niehgbours func node=\",node.value)\r\n    if (node[0] > 0) {\r\n        neighbours.push([[node[0] - 1, node[1]],false]);\r\n        if (node[1] > 0) {\r\n            neighbours.push([[node[0] - 1, node[1] - 1],true]);\r\n        }\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([[node[0], node[1] - 1],false]);\r\n        if (node[0] < ROWS - 1) {\r\n            neighbours.push([[node[0] + 1, node[1] - 1],true]);\r\n        }\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([[node[0] + 1, node[1]],false]);\r\n        if (node[1] < COLS - 1) {\r\n            neighbours.push([[node[0] + 1, node[1] + 1],true]);\r\n        }\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([[node[0], node[1] + 1],false]);\r\n        if (node[0] > 0) {\r\n            neighbours.push([[node[0] - 1, node[1] + 1],true]);\r\n        }\r\n    }\r\n\r\n    return neighbours;\r\n}\r\nexport const getFourNeighbours = (node, ROWS, COLS) => {\r\n    let neighbours = [];\r\n    if (node[0] > 0) {\r\n        neighbours.push([[node[0] - 1, node[1]],false]);\r\n    }\r\n    if (node[1] > 0) {\r\n        neighbours.push([[node[0], node[1] - 1],false]);\r\n    }\r\n    if (node[0] < ROWS - 1) {\r\n        neighbours.push([[node[0] + 1, node[1]],false]);\r\n    }\r\n    if (node[1] < COLS - 1) {\r\n        neighbours.push([[node[0], node[1] + 1],false]);\r\n    }\r\n\r\n    return neighbours;\r\n\r\n}","\r\nexport default class BinaryHeap {\r\n    constructor() {\r\n        this.values = [];\r\n    }\r\n    length() {\r\n        return this.values.length;\r\n    }\r\n    add(element) {\r\n        this.values.push(element);\r\n        let index = this.values.length - 1;\r\n        const current = this.values[index];\r\n\r\n        while (index > 0) {\r\n            let parentIndex = Math.floor((index - 1) / 2);\r\n            let parent = this.values[parentIndex];\r\n\r\n            const parentPriority = parent[parent.length - 2];\r\n            const currentPriority = current[current.length - 2];\r\n\r\n            if (parentPriority > currentPriority) {\r\n                this.values[parentIndex] = current;\r\n                this.values[index] = parent;\r\n                index = parentIndex;\r\n            } else break;\r\n        }\r\n    }\r\n    remove(node) {\r\n        for (let i = 0; i < this.values.length; i++) {\r\n            const current = this.values[i];\r\n            if (current[0] === node[0] && current[1] === node[1]) {\r\n                this.values.splice(i,1);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    get(node) {\r\n        for (let i = 0; i < this.values.length; i++) {\r\n            const current = this.values[i];\r\n            if (current[0] === node[0] && current[1] === node[1]) {\r\n                return current;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    contains(node) {\r\n        for (let i = 0; i < this.values.length; i++) {\r\n            const current = this.values[i];\r\n            if (current[0] === node[0] && current[1] === node[1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    peekMin() {\r\n        if (this.values.length > 0) return this.values[0];\r\n        return -1;\r\n    }\r\n    removeMin() {\r\n        const min = this.values[0];\r\n        const end = this.values.pop();\r\n        this.values[0] = end;\r\n\r\n        let index = 0;\r\n        const length = this.values.length;\r\n        const current = this.values[0];\r\n        while (true) {\r\n            let leftChildIndex = 2 * index + 1;\r\n            let rightChildIndex = 2 * index + 2;\r\n            let leftChild, rightChild;\r\n            let temp = null;\r\n\r\n            let leftPriority,rightPriority;\r\n            let currentPriority = current[current.length - 2];\r\n\r\n            if (leftChildIndex < length) {\r\n                leftChild = this.values[leftChildIndex];\r\n                leftPriority = leftChild[leftChild.length - 2];\r\n                currentPriority = current[current.length - 2];\r\n                if (leftPriority < currentPriority) temp = leftChildIndex;\r\n            }\r\n            if (rightChildIndex < length) {\r\n                rightChild = this.values[rightChildIndex];\r\n                leftPriority = leftChild[leftChild.length - 2];\r\n                rightPriority = rightChild[rightChild.length - 2]; \r\n                if ((temp === null && rightPriority < currentPriority) || (temp !== null && rightPriority < leftPriority)){\r\n                    temp = rightChildIndex;\r\n                }\r\n            }\r\n\r\n            if (temp === null) break;\r\n            this.values[index] = this.values[temp];\r\n            this.values[temp] = current;\r\n            index = temp;\r\n        }\r\n\r\n        return min;\r\n    }\r\n}","\r\nimport { getFourNeighbours, getEightNeighbours } from './common_methods/methods';\r\nimport BinaryHeap from '../Components/binaryHeap';\r\n\r\n\r\n\r\n\r\n/*\r\n        list        heap\r\nadd     1           O(logN)\r\nfindMin O(N)        O(1)\r\ncontains O(N)       o(N)\r\n\r\n*/\r\n\r\nexport const a_star_search = (ROWS, COLS, startLoc, endLoc, Grid, chosenDirection) => {\r\n    console.log(\"rows=\", ROWS, \" cols=\", COLS, \" startLoc=\", startLoc, \"  endloc=\", endLoc, \"  grid=\", Grid);\r\n\r\n    let open_nodes = new BinaryHeap();\r\n    open_nodes.add([startLoc[0], startLoc[1], 0, 0, 0])\r\n    let closed_nodes = [];\r\n\r\n    while (open_nodes.length() >0 && open_nodes.length() < 1000) {\r\n\r\n        // let node_lowest_cost = open_nodes.peekMin();\r\n        let node_lowest_cost = open_nodes.removeMin();\r\n\r\n        if (node_lowest_cost === undefined) break;\r\n\r\n        console.log(\"lowest=\", node_lowest_cost);\r\n        console.log(\"chosen from\", open_nodes);\r\n        // while(contains(closed_nodes,node_lowest_cost) && open_nodes.length()>0) node_lowest_cost=open_nodes.removeMin();\r\n        \r\n        let neighbours;\r\n        if (chosenDirection.indexOf(\"4\") > -1) {\r\n            neighbours = getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n        else {\r\n            neighbours = getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n        // console.log(\"neighbours================\", neighbours);\r\n        \r\n        \r\n\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i][0];\r\n            const isDiagonal = neighbours[i][1];\r\n            let g_score, h_score, f_score = 0;\r\n\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n                continue;\r\n            }\r\n            else {\r\n                const parent_f_cost=node_lowest_cost[node_lowest_cost.length-2];\r\n                const parent_g_cost=node_lowest_cost[3];\r\n\r\n                if (isDiagonal) g_score = parent_g_cost + 2.4;\r\n                else g_score = parent_g_cost + 2;\r\n                h_score = distance_from_end(neighbour, endLoc);\r\n                f_score = g_score + h_score;\r\n            }\r\n\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                closed_nodes.push(node_lowest_cost);\r\n                closed_nodes.push([neighbour[0], neighbour[1], h_score, g_score, f_score,node_lowest_cost]);\r\n                console.log(\"end found at:\", endLoc);\r\n                return closed_nodes;\r\n            }\r\n            \r\n            if(!contains(closed_nodes, neighbour)){\r\n                if(!open_nodes.contains(neighbour)){\r\n                    open_nodes.add([neighbour[0], neighbour[1], h_score, g_score, f_score, node_lowest_cost]);\r\n                }\r\n                else{\r\n                    const visitedNeighbour=open_nodes.get(neighbour);\r\n                    const visited_g_score=visitedNeighbour[3];\r\n                    if(visited_g_score>g_score){\r\n                        // new path is better\r\n                        open_nodes.remove(neighbour);\r\n                        open_nodes.add([neighbour[0], neighbour[1], h_score, g_score, f_score, node_lowest_cost]);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            \r\n\r\n           \r\n        }\r\n        open_nodes.remove(node_lowest_cost);\r\n        // if (!contains(closed_nodes, node_lowest_cost)) {\r\n            closed_nodes.push(node_lowest_cost);\r\n        // }\r\n        // if (closed_nodes.length > 0) {\r\n        //     const last_closed = closed_nodes[closed_nodes.length - 1];\r\n        //     if (last_closed[0] === endLoc[0] && last_closed[1] === endLoc[1]) {\r\n        //         return closed_nodes;\r\n        //     }\r\n        // }\r\n        \r\n    }\r\n\r\n    return closed_nodes;\r\n\r\n}\r\n\r\n\r\nconst distance_from_end = (node, endLoc) => {\r\n    //  console.log(\"distance end====================================\",node,\"  endLoc=\",endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n// export const a_star_search = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n\r\n\r\n//     console.log(\"rows=\",ROWS,\" cols=\",COLS,\" startLoc=\",startLoc,\"  endloc=\",endLoc,\"  grid=\",Grid);\r\n\r\n//     let open_nodes = [[startLoc[0], startLoc[1], 0, 0, 0]];\r\n//     let closed_nodes = [];\r\n\r\n//     while (open_nodes.length > 0 && open_nodes.length < 20000) {\r\n\r\n//         const node_lowest_cost = find_lowest_node(open_nodes, closed_nodes);\r\n//         if (node_lowest_cost === undefined) break;\r\n\r\n//         // console.log(\"lowest=\", node_lowest_cost);\r\n//         // console.log(\"chosen from\", open_nodes);\r\n\r\n//         let neighbours;\r\n//         if(chosenDirection.indexOf(\"4\")>-1){\r\n//             neighbours= getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n//         else{\r\n//             neighbours= getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n//         // console.log(\"neighbours================\",neighbours);\r\n//         for (let i = 0; i < neighbours.length; i++) {\r\n//             const neighbour = neighbours[i][0];\r\n//             const isDiagonal=neighbours[i][1];\r\n//             let g_score, h_score, f_score = 0;\r\n\r\n//             if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n//                 continue;\r\n//                 // console.log(\"isWall\")\r\n//                 // g_score = 10000;\r\n//                 // h_score = 10000;\r\n//                 // f_score = g_score + h_score;\r\n//             }\r\n//             else {\r\n//                 if(isDiagonal) g_score = node_lowest_cost[2] + 2.4;\r\n//                 else g_score = node_lowest_cost[2] + 2;\r\n\r\n//                 h_score = distance_from_end(neighbour,endLoc);\r\n//                 f_score = g_score + h_score;\r\n//             }\r\n\r\n\r\n//             if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n//                 closed_nodes.push(node_lowest_cost);\r\n//                 closed_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n//                 console.log(\"end found at:\",endLoc);\r\n//                 return closed_nodes;\r\n//             }\r\n\r\n//             if (contains(open_nodes, neighbour)) {\r\n//                 // if (distance_from_start(neighbour) <= f_score) console.log(\"1st if \", neighbour);\r\n//             }\r\n//             else if (contains(closed_nodes, neighbour)) {\r\n//                 // console.log(\"neighbour \", neighbour, \" in closed list\");\r\n//                 // if (distance_from_start(neighbour) <= f_score) console.log(\"2nd if \", neighbour);\r\n//                 // else {\r\n//                 // console.log(\"closed_nodes l=\", closed_nodes.length)\r\n//                 remove(closed_nodes, neighbour);\r\n//                 // console.log(\"closed_nodes AFTER l=\", closed_nodes.length);\r\n//                 open_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n//                 // }\r\n\r\n//             }\r\n//             else {\r\n//                 open_nodes.push([neighbour[0], neighbour[1], f_score, h_score, g_score, node_lowest_cost]);\r\n//             }\r\n//         }\r\n//         if (closed_nodes.length > 0) {\r\n//             const last_closed = closed_nodes[closed_nodes.length - 1];\r\n//             if (last_closed[0] === endLoc[0] && last_closed[1] === endLoc[1]) {       \r\n//                 return closed_nodes;\r\n//             }\r\n//         }\r\n//         if (!contains(closed_nodes, node_lowest_cost)) {\r\n//             closed_nodes.push(node_lowest_cost);\r\n//         }\r\n//     }\r\n\r\n//     return closed_nodes;\r\n\r\n// }\r\n\r\n\r\n//  const distance_from_end = (node,endLoc) => {\r\n//     //  console.log(\"distance end====================================\",node,\"  endLoc=\",endLoc);\r\n//     const x = Math.abs(node[0] - endLoc[0]);\r\n//     const y = Math.abs(node[1] - endLoc[1]);\r\n//     return ((x * x) + (y * y))\r\n\r\n// }\r\n\r\n\r\n//  const contains = (discovered_nodes, node) => {\r\n//     for (let i = 0; i < discovered_nodes.length; i++) {\r\n//         if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n//             return true;\r\n//         }\r\n//     }\r\n//     return false;\r\n// }\r\n\r\n//  const remove = (list, node) => {\r\n//     for (let i = 0; i < list.length; i++) {\r\n//         if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n//             return list.splice(i, 1);\r\n//         }\r\n//     }\r\n// }\r\nconst find_lowest_node = (discovered_nodes, path) => {\r\n    const copy = discovered_nodes.slice();\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_heuristic = 10000000;\r\n    let min_distance_to_end = 1000000;\r\n    let node;\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][2] < min_heuristic && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            min_distance_to_end = discovered_nodes[i][3];\r\n            node = discovered_nodes[i];\r\n        }\r\n        else if (discovered_nodes[i][2] === min_heuristic && discovered_nodes[i][3] < min_distance_to_end && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            min_distance_to_end = discovered_nodes[i][3];\r\n            node = discovered_nodes[i];\r\n            // console.log(\"found lowest \", node);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\n","import {getFourNeighbours,getEightNeighbours} from './common_methods/methods';\r\nimport BinaryHeap from '../Components/binaryHeap';\r\n\r\n\r\nexport const dijkstra_algorithm = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let visited = [];\r\n    let unvisited =new BinaryHeap();\r\n    unvisited.add([startLoc[0], startLoc[1], 0, null]);\r\n\r\n\r\n\r\n    while (unvisited.length() > 0 && unvisited.length() < 20000) {\r\n\r\n        const node_lowest_cost = unvisited.removeMin();\r\n        \r\n        if (node_lowest_cost[0] === endLoc[0] && node_lowest_cost[1] === endLoc[1]) {\r\n            visited.push(node_lowest_cost);\r\n            // visited.push([neighbour[0], neighbour[1], cost, node_lowest_cost]);\r\n            // console.log(\"end found\");\r\n            return visited;\r\n        }\r\n        \r\n        \r\n        console.log(\"low=\",node_lowest_cost);\r\n        let neighbours;\r\n        if (node_lowest_cost === undefined) { console.log(\"node_lowest=undefined so break\"); break; }\r\n        \r\n        if(chosenDirection.indexOf(\"4\")>-1){\r\n            neighbours= getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n        else{\r\n            neighbours= getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n        \r\n        \r\n        \r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i][0];\r\n            const isDiagonal=neighbours[i][1];\r\n            if (contains(visited, neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n                continue\r\n            }\r\n            else {\r\n                if(isDiagonal) cost = 1.41 + node_lowest_cost[2];\r\n                else cost = 1 + node_lowest_cost[2];\r\n                \r\n            }\r\n            \r\n            unvisited=update_cost(neighbour, cost, node_lowest_cost, unvisited);\r\n\r\n        }\r\n        unvisited.remove(node_lowest_cost);\r\n        // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n        visited.push(node_lowest_cost);\r\n        // console.log(\"visited=\" + visited);\r\n        // console.log(\"not visited=\" + unvisited);\r\n\r\n\r\n    }\r\n    return visited;\r\n\r\n\r\n}\r\n\r\nconst update_cost = (node, cost, previous, unvisited) => {\r\n    \r\n    if(unvisited.contains(node)){\r\n        const visitedNode=unvisited.get(node);\r\n        const visitedCost=visitedNode[visitedNode.length-2];\r\n        if(visitedCost>cost){\r\n            unvisited.remove(node);\r\n            unvisited.add([node[0], node[1], cost, previous]);\r\n        }\r\n        \r\n    }\r\n    else unvisited.add([node[0], node[1], cost, previous]);\r\n    \r\n    return unvisited;\r\n    \r\n}\r\n\r\n// export const dijkstra_algorithm = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n//     /*\r\n//     create unvisited list\r\n//         Node | Cost (from start) | Previous node\r\n    \r\n//     1. Assign starting node cost=0\r\n//     2. Assign all other nodes cost=10000\r\n//     3. Assign none for previous for all nodes\r\n\r\n//     create visited list\r\n    \r\n//     REPEAT \r\n//     4. Choose lowest cost node - from unvisited and put into visited\r\n//     5.Get node neighbours that are unvisited\r\n//     6.Update unvisted list costs\r\n//         if current cost+new node edge cost> new node current cost\r\n//             don't update the cost\r\n//         else \r\n//             update cost and previous\r\n    \r\n//     */\r\n\r\n\r\n//     //                 -------Node------------ | Cost | Previous\r\n//     let visited = [];\r\n//     let unvisited =new BinaryHeap();\r\n//     unvisited.add([startLoc[0], startLoc[1], 0, null]);\r\n\r\n\r\n\r\n//     while (unvisited.length() > 0 && unvisited.length() < 20000) {\r\n\r\n//         const node_lowest_cost = unvisited.peekMin();\r\n        \r\n//         let neighbours;\r\n//         if (node_lowest_cost === undefined) { console.log(\"node_lowest=undefined so break\"); break; }\r\n        \r\n//         if(chosenDirection.indexOf(\"4\")>-1){\r\n//             neighbours= getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n//         else{\r\n//             neighbours= getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n        \r\n        \r\n        \r\n//         for (let i = 0; i < neighbours.length; i++) {\r\n//             const neighbour = neighbours[i][0];\r\n//             const isDiagonal=neighbours[i][1];\r\n//             if (contains(visited, neighbour)) continue;\r\n//             let cost = 0;\r\n//             if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n//                 continue\r\n//             }\r\n//             else {\r\n//                 if(isDiagonal) cost = 1.41 + node_lowest_cost[2];\r\n//                 else cost = 1 + node_lowest_cost[2];\r\n                \r\n//             }\r\n//             if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n//                 visited.push(node_lowest_cost);\r\n//                 visited.push([neighbour[0], neighbour[1], cost, node_lowest_cost]);\r\n//                 // console.log(\"end found\");\r\n//                 return visited;\r\n//             }\r\n//             update_cost(neighbour, cost, node_lowest_cost, unvisited);\r\n\r\n//         }\r\n//         unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n//         visited.push(node_lowest_cost);\r\n//         // console.log(\"visited=\" + visited);\r\n//         // console.log(\"not visited=\" + unvisited);\r\n\r\n\r\n//     }\r\n//     return visited;\r\n\r\n\r\n// }\r\n\r\n// const update_cost = (node, cost, previous, unvisited) => {\r\n//     let found = false;\r\n//     for (let i = 0; i < unvisited.length; i++) {\r\n//         let current = unvisited[i];\r\n//         if (current[0] == node[0] && current[1] == node[1]) {\r\n//             found = true;\r\n//             if (unvisited[2] > cost) {\r\n//                 unvisited[2] = cost;\r\n//                 unvisited[3] = previous;\r\n//                 return unvisited;\r\n//             }\r\n//         }\r\n//     }\r\n//     if (!found) unvisited.push([node[0], node[1], cost, previous]);\r\n//     return unvisited;\r\n// }\r\nconst remove_from_unvisited = (node, unvisited) => {\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) unvisited.splice(i, 1);\r\n    }\r\n    return unvisited;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst distance_from_start = (node, startLoc) => {\r\n    const x = Math.abs(node[0] - startLoc[0]);\r\n    const y = Math.abs(node[1] - startLoc[1]);\r\n    return ((x * x) + (y * y))\r\n}\r\nconst distance_from_end = (node, endLoc) => {\r\n    // console.log(\"distance end====================================\", node, \"  endLoc=\", endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return ((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (unvisted) => {\r\n\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_cost = 10000000;\r\n    let node;\r\n    for (let i = 0; i < unvisted.length; i++) {\r\n        if (unvisted[i][2] < min_cost) {\r\n            min_cost = unvisted[i][2];\r\n            node = unvisted[i];\r\n        }\r\n\r\n    }\r\n    return node;\r\n}\r\n\r\n","import {getFourNeighbours,getEightNeighbours} from './common_methods/methods';\r\n\r\n\r\nexport const bfs = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let removed=[];\r\n    let queue = [[startLoc[0], startLoc[1], 0, null]];\r\n    while (queue.length>0) {\r\n\r\n        const head = queue[0];\r\n\r\n        if (head === undefined) { console.log(\"head=undefined so break\"); break; }\r\n\r\n        let neighbours;\r\n        if(chosenDirection.indexOf(\"4\")>-1){\r\n            neighbours= getFourNeighbours(head, ROWS, COLS);\r\n        }\r\n        else{\r\n            neighbours= getEightNeighbours(head, ROWS, COLS);\r\n        }\r\n\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i][0];\r\n            const isDiagonal=neighbours[i][1];\r\n            \r\n            if (contains(queue, neighbour) || contains(removed,neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n                continue\r\n            }\r\n            else {\r\n                if(isDiagonal) cost = 1.41 + head[2];\r\n                else cost = 1 + head[2];\r\n                \r\n            }\r\n            queue.push([neighbour[0], neighbour[1], cost, head]);\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                removed.push(queue.shift());\r\n                removed.push([neighbour[0], neighbour[1], cost, head]);\r\n                return removed;\r\n            }  \r\n\r\n        }\r\n        removed.push(queue.shift());\r\n        // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n     \r\n\r\n\r\n    }\r\n    return removed;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n\r\n","import {getFourNeighbours,getEightNeighbours} from './common_methods/methods';\r\n\r\n\r\nexport const dfs = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n\r\n\r\n    /*\r\n    create unvisited list\r\n        Node | Cost (from start) | Previous node\r\n    \r\n    1. Assign starting node cost=0\r\n    2. Assign all other nodes cost=10000\r\n    3. Assign none for previous for all nodes\r\n\r\n    create visited list\r\n    \r\n    REPEAT \r\n    4. Choose lowest cost node - from unvisited and put into visited\r\n    5.Get node neighbours that are unvisited\r\n    6.Update unvisted list costs\r\n        if current cost+new node edge cost> new node current cost\r\n            don't update the cost\r\n        else \r\n            update cost and previous\r\n    \r\n    */\r\n\r\n\r\n    //                 -------Node------------ | Cost | Previous\r\n    let removed=[];\r\n    let stack = [[startLoc[0], startLoc[1], 0, null]];\r\n    while (stack.length>=0 && stack.length<1000) {\r\n\r\n        const head = stack[stack.length-1];\r\n        console.log(\"stack =\",stack);\r\n        if (head === undefined) { \r\n            // stack.splice(stack.length-1,1);\r\n            console.log(\"head=undefined so break\"); \r\n            break; \r\n        }\r\n        removed.push(head);\r\n        stack.splice(stack.length-1,1);\r\n        \r\n\r\n        let neighbours;\r\n\r\n        if(chosenDirection.indexOf(\"4\")>-1){\r\n            neighbours= getFourNeighbours(head, ROWS, COLS);\r\n        }\r\n        else{\r\n            neighbours= getEightNeighbours(head, ROWS, COLS);\r\n        }\r\n        \r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i][0];\r\n            const isDiagonal=neighbours[i][1];\r\n            //if node already in stack, then remove it and push it to the back\r\n            if (contains(removed,neighbour)) continue;\r\n            let cost = 0;\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n                continue\r\n            }\r\n            else {\r\n                if(isDiagonal) cost = 1.41 + head[2];\r\n                else cost = 1 + head[2];\r\n            }\r\n            stack.push([neighbour[0], neighbour[1], cost, head]);\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                removed.push(head);\r\n                removed.push([neighbour[0], neighbour[1], cost, head]);\r\n                return removed;\r\n            }  \r\n\r\n        }\r\n        \r\n        // unvisited = remove_from_unvisited(node_lowest_cost, unvisited);\r\n     \r\n\r\n\r\n    }\r\n    \r\n    console.log(\"dfs returns=\",removed);\r\n    return removed;\r\n\r\n\r\n}\r\nconst update_cost = (node, cost, previous, unvisited) => {\r\n    let found = false;\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) {\r\n            found = true;\r\n            if (unvisited[2] > cost) {\r\n                unvisited[2] = cost;\r\n                unvisited[3] = previous;\r\n                return unvisited;\r\n            }\r\n        }\r\n    }\r\n    if (!found) unvisited.push([node[0], node[1], cost, previous]);\r\n    return unvisited;\r\n}\r\nconst remove_from_unvisited = (node, unvisited) => {\r\n\r\n    for (let i = 0; i < unvisited.length; i++) {\r\n        let current = unvisited[i];\r\n        if (current[0] == node[0] && current[1] == node[1]) unvisited.splice(i, 1);\r\n    }\r\n    return unvisited;\r\n}\r\n\r\n\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (unvisted) => {\r\n\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_cost = 10000000;\r\n    let node;\r\n    for (let i = 0; i < unvisted.length; i++) {\r\n        if (unvisted[i][2] < min_cost) {\r\n            min_cost = unvisted[i][2];\r\n            node = unvisted[i];\r\n        }\r\n\r\n    }\r\n    return node;\r\n}\r\n\r\n","import { getFourNeighbours, getEightNeighbours } from './common_methods/methods';\r\nimport BinaryHeap from '../Components/binaryHeap';\r\n\r\n\r\nexport const best_first = (ROWS, COLS, startLoc, endLoc, Grid, chosenDirection) => {\r\n    console.log(\"rows=\", ROWS, \" cols=\", COLS, \" startLoc=\", startLoc, \"  endloc=\", endLoc, \"  grid=\", Grid);\r\n\r\n    let open_nodes = new BinaryHeap();\r\n    open_nodes.add([startLoc[0], startLoc[1], 0, 0, 0])\r\n    let closed_nodes = [];\r\n\r\n    while (open_nodes.length() > 0 && open_nodes.length() < 2000) {\r\n\r\n        const node_lowest_cost = open_nodes.removeMin();\r\n\r\n        if (node_lowest_cost === undefined) break;\r\n\r\n        console.log(\"lowest=\", node_lowest_cost);\r\n\r\n\r\n        let neighbours;\r\n        if (chosenDirection.indexOf(\"4\") > -1) {\r\n            neighbours = getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n        else {\r\n            neighbours = getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n        }\r\n\r\n\r\n\r\n        for (let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i][0];\r\n            let h_score;\r\n\r\n            if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n                continue;\r\n            }\r\n            else {\r\n                h_score = distance_from_end(neighbour, endLoc);\r\n            }\r\n\r\n            if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n                closed_nodes.push(node_lowest_cost);\r\n                closed_nodes.push([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n                console.log(\"end found at:\", endLoc);\r\n                return closed_nodes;\r\n            }\r\n\r\n            if (open_nodes.contains(neighbour)) {\r\n                const visitedNeighbour = open_nodes.get(neighbour);\r\n                const visited_h_score = visitedNeighbour[visitedNeighbour.length - 2];\r\n                if (visited_h_score >= h_score) {\r\n                    open_nodes.remove(neighbour);\r\n                    open_nodes.add([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n                }\r\n            }\r\n            else if (contains(closed_nodes, neighbour)) {\r\n                continue;\r\n            }\r\n            else {\r\n                open_nodes.add([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n            }\r\n        }\r\n        open_nodes.remove(node_lowest_cost);\r\n        if (!contains(closed_nodes, node_lowest_cost)) {\r\n            closed_nodes.push(node_lowest_cost);\r\n        }\r\n    }\r\n\r\n    return closed_nodes;\r\n\r\n}\r\n\r\n// export const best_first = (ROWS, COLS, startLoc, endLoc, Grid,chosenDirection) => {\r\n\r\n\r\n//     console.log(\"rows=\",ROWS,\" cols=\",COLS,\" startLoc=\",startLoc,\"  endloc=\",endLoc,\"  grid=\",Grid);\r\n\r\n//     let open_nodes = new BinaryHeap();\r\n//     open_nodes.add([startLoc[0], startLoc[1], 0, 0, 0])\r\n//     let closed_nodes = [];\r\n\r\n//     while (open_nodes.length() > 0 && open_nodes.length() < 20000) {\r\n//         const node_lowest_cost = find_lowest_node(open_nodes, closed_nodes);\r\n//         if (node_lowest_cost === undefined) break;\r\n\r\n//         // console.log(\"lowest=\", node_lowest_cost);\r\n//         // console.log(\"chosen from\", open_nodes);\r\n\r\n\r\n//         let neighbours;\r\n\r\n//         if(chosenDirection.indexOf(\"4\")>-1){\r\n//             neighbours= getFourNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n//         else{\r\n//             neighbours= getEightNeighbours(node_lowest_cost, ROWS, COLS);\r\n//         }\r\n//         // console.log(\"neighbours================\",neighbours);\r\n//         for (let i = 0; i < neighbours.length; i++) {\r\n//             const neighbour = neighbours[i][0];\r\n//             const isDiagonal=neighbours[i][1];\r\n//             let h_score= 0;\r\n\r\n//             if (Grid[neighbour[0]][neighbour[1]].props.isWall && !Grid[neighbour[0]][neighbour[1]].props.isEnd) {\r\n//                 continue;\r\n//             }\r\n//             else {\r\n//                 h_score = distance_from_end(neighbour,endLoc);\r\n//             }\r\n\r\n\r\n//             if (neighbour[0] === endLoc[0] && neighbour[1] === endLoc[1]) {\r\n//                 closed_nodes.push(node_lowest_cost);\r\n//                 closed_nodes.push([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n//                 // console.log(\"end found\");\r\n//                 return closed_nodes;\r\n//             }\r\n\r\n//             if (contains(open_nodes, neighbour)) {\r\n//                 // if (distance_from_start(neighbour) <= f_score) console.log(\"1st if \", neighbour);\r\n//             }\r\n//             else if (contains(closed_nodes, neighbour)) {\r\n//                 // console.log(\"neighbour \", neighbour, \" in closed list\");\r\n//                 // if (distance_from_start(neighbour) <= f_score) console.log(\"2nd if \", neighbour);\r\n//                 // else {\r\n//                 // console.log(\"closed_nodes l=\", closed_nodes.length)\r\n//                 remove(closed_nodes, neighbour);\r\n//                 // console.log(\"closed_nodes AFTER l=\", closed_nodes.length);\r\n//                 open_nodes.push([neighbour[0], neighbour[1],h_score, node_lowest_cost]);\r\n//                 // }\r\n\r\n//             }\r\n//             else {\r\n//                 open_nodes.push([neighbour[0], neighbour[1], h_score, node_lowest_cost]);\r\n//             }\r\n//         }\r\n//         if (closed_nodes.length > 0) {\r\n//             const last_closed = closed_nodes[closed_nodes.length - 1];\r\n//             if (last_closed[0] === endLoc[0] && last_closed[1] === endLoc[1]) {\r\n//                 return closed_nodes;\r\n//             }\r\n//         }\r\n\r\n//         if (!contains(closed_nodes, node_lowest_cost)) {\r\n//             closed_nodes.push(node_lowest_cost);\r\n//         }\r\n\r\n//         // remove(open_nodes, node_lowest_cost);\r\n//         // console.log(\"dn=\", open_nodes);\r\n\r\n\r\n//         // break\r\n//     }\r\n//     // console.log(\"path=\", closed_nodes);\r\n\r\n//     return closed_nodes;\r\n\r\n// }\r\n\r\n\r\n\r\nconst distance_from_end = (node, endLoc) => {\r\n    //  console.log(\"distance end====================================\",node,\"  endLoc=\",endLoc);\r\n    const x = Math.abs(node[0] - endLoc[0]);\r\n    const y = Math.abs(node[1] - endLoc[1]);\r\n    return Math.sqrt((x * x) + (y * y))\r\n\r\n}\r\n\r\n\r\nconst contains = (discovered_nodes, node) => {\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][0] === node[0] && discovered_nodes[i][1] === node[1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst remove = (list, node) => {\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (list[i][0] === node[0] && list[i][1] === node[1]) {\r\n            return list.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nconst find_lowest_node = (discovered_nodes, path) => {\r\n    const copy = discovered_nodes.slice();\r\n    // console.log(\"find lowest slice=\", copy);\r\n    let min_heuristic = 10000000;\r\n    let node;\r\n    for (let i = 0; i < discovered_nodes.length; i++) {\r\n        if (discovered_nodes[i][2] < min_heuristic && !contains(path, discovered_nodes[i])) {\r\n            min_heuristic = discovered_nodes[i][2];\r\n            node = discovered_nodes[i];\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\n","import Node from '../Components/Node';\r\n\r\nexport function timeout(delay) {\r\n    return new Promise(res => setTimeout(res, delay));\r\n}\r\n\r\nexport const findPathFromClosed = async (closed_nodes, startLoc) => {\r\n    console.log(\"given=\", closed_nodes);\r\n    let path = [];\r\n    let found_start = false;\r\n    let last = closed_nodes[closed_nodes.length - 1];\r\n    while (found_start === false) {\r\n        path.unshift(last);\r\n        \r\n        if (last === undefined || last===null) break;\r\n        if (last[0] === startLoc[0] && last[1] === startLoc[1]) found_start = true;\r\n        else {\r\n            last = last[last.length - 1];\r\n        }\r\n    }\r\n    console.log(\"findPathFromClosed\", path);\r\n    return path;\r\n}\r\nexport const findPathBidirectional = async (closed_nodes, targetNode) => {\r\n    // 1. Find 1st intersect\r\n    //Backtrack from it\r\n    let path = [];\r\n    let intersectOne;\r\n    for (let i = 0; i < closed_nodes.length; i++) {\r\n        const node = closed_nodes[i];\r\n        if (node[0] === targetNode[0] && node[1] === targetNode[1]) {\r\n            intersectOne = node;\r\n            break;\r\n        }\r\n    }\r\n    let one = backTrack(intersectOne);\r\n    let two = backTrack(targetNode);\r\n\r\n    // let pathA=\r\n\r\n    return one.concat(two);\r\n}\r\nconst backTrack = (node) => {\r\n    let list = [node];\r\n    let iterator = node;\r\n    while (iterator !== undefined && iterator[3] !== null) {\r\n        list.push(iterator[3]);\r\n        iterator = iterator[3];\r\n    }\r\n    // console.log(\"backTrack from node=\",node,\" is=\",list);\r\n    return list;\r\n}\r\nexport const drawPath = async (Grid, path, i, type) => {\r\n    const newGrid = Grid.slice();\r\n    if (i > 0 && i <= path.length - 1) {\r\n        if(path[i]===undefined || path[i]===null) return newGrid;\r\n        const x = path[i][0];\r\n        const y = path[i][1];\r\n        if (x === undefined || y === undefined) return newGrid;\r\n        if (newGrid[x][y].props.isBomb) return newGrid;\r\n        if (type === \"visited\") {\r\n            newGrid[x][y] = <Node\r\n                isWall={false}\r\n                isBomb={Grid[x][y].props.isBomb}\r\n                isStart={Grid[x][y].props.isStart}\r\n                isEnd={Grid[x][y].props.isEnd}\r\n                isPath={false}\r\n                isVisited={true}\r\n            />;\r\n        }\r\n        else {\r\n            newGrid[x][y] = <Node\r\n                isWall={false}\r\n                isBomb={Grid[x][y].props.isBomb}\r\n                isStart={Grid[x][y].props.isStart}\r\n                isEnd={Grid[x][y].props.isEnd}\r\n                isPath={true}\r\n                isVisited={false}\r\n            />;\r\n        }\r\n    }\r\n    return newGrid;\r\n\r\n\r\n}\r\nexport const createBombVisit = (firstList, secondList) => {\r\n    console.log(\"secondList=\", secondList);\r\n    console.log(\"firstList*=\", firstList);\r\n\r\n    // secondList.shift();\r\n    // secondList[secondList.length - 1][secondList[0].length - 1] = firstList[firstList.length - 1];\r\n    secondList[0][secondList[0].length - 1] = firstList[firstList.length - 1];\r\n    const finalList = firstList.concat(secondList);\r\n    \r\n    \r\n    return finalList;\r\n    \r\n}","import React, { useState, useEffect } from 'react';\r\nimport '../CSS/dropdown.css';\r\n\r\nfunction Dropdown(props) {\r\n    useEffect(() => {\r\n        setOptions(props.options) //> I'm dispatching an action here.\r\n    }, [props.options])\r\n\r\n    const [options, setOptions] = useState([]);\r\n    const [hovered, setHover] = useState(false);\r\n    const [mainValue, setMainValue] = useState(props.default);\r\n\r\n    let menuOptions=[];\r\n    for(const value of options){\r\n        menuOptions.push(<p key={value} onClick={()=>changeValue(value)} className={\"item\"}>{value}</p>)\r\n    }\r\n    \r\n    const changeValue=(value)=>{\r\n        setMainValue(value);\r\n        props.dropDownValueChanged(value);\r\n    }\r\n\r\n    return (\r\n        <div className={\"dropdownContainer\"}  onMouseEnter={() => setHover(true)} onMouseLeave={() => setHover(false)} >\r\n            <div className={\"dropdown\"}>\r\n                <p key={mainValue} className={\"value\"}>{mainValue}</p>\r\n            </div>\r\n            {hovered && (\r\n                <div className={\"subMenu\"}>\r\n                    {menuOptions}\r\n                </div>\r\n            )}\r\n        </div>\r\n\r\n    )\r\n}\r\nexport default Dropdown;","import Node from '../Components/Node';\r\n\r\nexport const makeMaze = (startLoc, endLoc, grid, chosenMap) => {\r\n    chosenMap = setChosenMap(chosenMap);\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[i].length; j++) {\r\n            if ((i == startLoc[0] && j == startLoc[1]) || (i == endLoc[0] && j == endLoc[1])) continue;\r\n            if (chosenMap[i][j] !== undefined && chosenMap[i][j] === 1) {\r\n                grid[i][j] = <Node\r\n                    isWall={true}\r\n                    isStart={false}\r\n                    isPath={false}\r\n                    isVisited={false}\r\n                    isEnd={false}\r\n                />;\r\n            }\r\n        }\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst setChosenMap = (choice) => {\r\n    choice = choice.toLowerCase();\r\n    if (choice === \"loop\") {\r\n        return loopMap;\r\n    }\r\n    else if (choice === \"maze 1\") {\r\n        return maze_1;\r\n    }\r\n    else if (choice === \"maze 2\") {\r\n        return maze_2;\r\n    }\r\n    else if (choice === \"boxed\") {\r\n        return boxes;\r\n    }\r\n    else if (choice === \"small boxed\") {\r\n        return smallBoxed;\r\n    }\r\n}\r\n\r\n\r\nconst maze = [\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n]\r\n\r\nconst maze_1 = [\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n    [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],\r\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],\r\n    [0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1],\r\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n    [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\r\n    [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\r\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\nconst maze_2 = [\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1],\r\n    [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1],\r\n    [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1],\r\n    [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1],\r\n    [1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],\r\n    [1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1],\r\n    [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\r\n    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1],\r\n    [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],\r\n    [1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n]\r\nconst loopMap = [\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]\r\n]\r\n\r\nconst boxes = [\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\r\n    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n]\r\nconst smallBoxed = [\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n]\r\n\r\n\r\n","import React, { useState, useEffect } from 'react';\r\nimport Node from './Node';\r\nimport '../CSS/grid.css';\r\n\r\nexport default function ColourCode(props) {\r\n    return (\r\n        <div className=\"keySet\">\r\n            <div className=\"key\">\r\n                <Node\r\n                    key={-1}\r\n                    isWall={true}\r\n                    isEnd={false}\r\n                    isPath={false}\r\n                    isVisited={false}\r\n                    isStart={false}\r\n                    \r\n                />\r\n                <h3>Wall</h3>\r\n            </div>\r\n            <div className=\"key\">\r\n                <Node\r\n                    key={-1}\r\n                    isWall={false}\r\n                    isEnd={false}\r\n                    isPath={false}\r\n                    isVisited={false}\r\n                    isStart={true}\r\n                    \r\n                />\r\n                <h3>Start</h3>\r\n            </div>\r\n            <div className=\"key\">\r\n                <Node\r\n                    key={-1}\r\n                    isWall={false}\r\n                    isEnd={true}\r\n                    isPath={false}\r\n                    isVisited={false}\r\n                    isStart={false}\r\n                    \r\n                />\r\n                <h3>End</h3>\r\n            </div>\r\n            <div className=\"key\">\r\n                <Node\r\n                    key={-1}\r\n                    isWall={false}\r\n                    isEnd={false}\r\n                    isPath={false}\r\n                    isVisited={true}\r\n                    isStart={false}\r\n                    \r\n                />\r\n                <h3>Visited</h3>\r\n            </div>\r\n            <div className=\"key\">\r\n                <Node\r\n                    key={-1}\r\n                    isWall={false}\r\n                    isEnd={false}\r\n                    isPath={true}\r\n                    isVisited={false}\r\n                    isStart={false}\r\n                    \r\n                />\r\n                <h3>Path</h3>\r\n            </div>\r\n\r\n        </div>\r\n    )\r\n}\r\n","import React, { useState, useEffect } from 'react';\r\nimport Node from './Node';\r\nimport '../CSS/grid.css';\r\n\r\nexport default function Results(props) {\r\n\r\n    useEffect(() => {\r\n        // setStartTime(props.startTime);\r\n        if(props.content===null){\r\n            setBody(body + '\\nNo path found for: '+props.chosenAlgorithm);\r\n        }\r\n        else if (props.content.length !== 0) {\r\n            const timeTaken=Math.round((performance.now() - props.startTime)/1000 * 100) / 100\r\n            \r\n            setBody(body + '\\n'+props.chosenAlgorithm+' Algorithm    |    Nodes Expanded = ' + props.expanded.length+'  |    Final Path Length = ' + props.content.length + \"    |    Time Taken = \" + timeTaken+\" seconds\")\r\n        }\r\n\r\n    }, [props.content])\r\n\r\n\r\n    const [body, setBody] = useState(\"\");\r\n\r\n\r\n\r\n    return (\r\n        <div className={\"resultContainer\"}>\r\n            <h3 className={\"resultHeader\"}>Results</h3>\r\n            <div className=\"resultBody\">\r\n                {body.split('\\n').map(line => <p>{line}</p>)}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import Node from '../Components/Node';\r\n\r\nexport const clearEverything = (ROWS, COLS, grid) => {\r\n  for (let y = 0; y < ROWS; y++) {\r\n    for (let x = 0; x < COLS; x++) {\r\n      grid[x][y] = <Node\r\n        isWall={false}\r\n        isPath={false}\r\n        isVisited={false}\r\n        isStart={grid[y][x].props.isStart}\r\n        isEnd={grid[y][x].props.isEnd}\r\n        isBomb={grid[y][x].props.isBomb}\r\n        />\r\n        \r\n    }\r\n  }\r\n  return grid;\r\n}\r\nexport const clear_old_path = (path, Grid) => {\r\n  if (path === null || path === undefined) return;\r\n  const newGrid = Grid.slice();\r\n\r\n  for (let i = 1; i < path.length - 1; i++) {\r\n    const x = path[i][0];\r\n    const y = path[i][1];\r\n    if(x===undefined || y===undefined) return newGrid;\r\n    newGrid[x][y] = <Node\r\n      isWall={Grid[x][y].props.isWall}\r\n      isStart={Grid[x][y].props.isStart}\r\n      isEnd={Grid[x][y].props.isEnd}\r\n      isPath={false}\r\n      isVisited={false}\r\n      isBomb={Grid[x][y].props.isBomb}\r\n    />;\r\n  }\r\n  return newGrid;\r\n}\r\nexport const clear_visited_path = (visitedPath, Grid) => {\r\n  const newGrid = Grid.slice();\r\n  for (let i = 1; i < visitedPath.length; i++) {\r\n    const x = visitedPath[i][0];\r\n    const y = visitedPath[i][1]\r\n    newGrid[x][y] = <Node\r\n      isWall={Grid[x][y].props.isWall}\r\n      isBomb={Grid[x][y].props.isBomb}\r\n      isStart={Grid[x][y].props.isStart}\r\n      isEnd={Grid[x][y].props.isEnd}\r\n      isPath={false}\r\n      isVisited={false}\r\n    />;\r\n  }\r\n  return newGrid;\r\n}\r\n\r\n\r\n\r\nexport const clearWalls = (Grid, ROWS, COLS) => {\r\n  let grid = [];\r\n  for (let y = 0; y < ROWS; y++) {\r\n    grid.push([]);\r\n    for (let x = 0; x < COLS; x++) {\r\n      grid[y].push(\r\n        <Node\r\n          // handleMouseDown={() => handleMouseDown(x, y)}\r\n          // handleMouseEnter={() => handleMouseEnter(x, y)}\r\n          // handleMouseUp={() => handleMouseUp(x, y)}\r\n          isWall={false}\r\n          isPath={false}\r\n          isVisited={false}\r\n          isStart={Grid[y][x].props.isStart}\r\n          isEnd={Grid[y][x].props.isEnd} \r\n          isBomb={Grid[y][x].props.isBomb}\r\n          />\r\n      );\r\n    }\r\n  }\r\n  return grid\r\n\r\n}\r\nexport const emptyGrid = (Grid, ROWS, COLS) => {\r\n  let grid = [];\r\n  for (let y = 0; y < ROWS; y++) {\r\n    grid.push([]);\r\n    for (let x = 0; x < COLS; x++) {\r\n      grid[y].push(\r\n        <Node\r\n          isWall={false}\r\n          isPath={false}\r\n          isVisited={false}\r\n          isStart={Grid[y][x].props.isStart}\r\n          isEnd={Grid[y][x].props.isEnd} />\r\n      );\r\n    }\r\n  }\r\n  return grid;\r\n\r\n}\r\nexport const setBomb = (Grid, x, y) => {\r\n  let grid = Grid.slice();\r\n  grid[x][y] =\r\n    <Node\r\n      isBomb={true}\r\n      isStart={Grid[x][y].props.isStart}\r\n      isEnd={Grid[x][y].props.isEnd} />\r\n  return grid;\r\n\r\n}\r\nexport const removeBomb = (Grid, x, y) => {\r\n  let grid = Grid.slice();\r\n  grid[x][y] =\r\n    <Node\r\n      isBomb={false}\r\n      isStart={Grid[x][y].props.isStart}\r\n      isEnd={Grid[x][y].props.isEnd} />\r\n  return grid;\r\n\r\n}\r\nexport const speedSetter=(setting)=>{\r\n  setting=setting.toLowerCase();\r\n  if(setting===\"very fast\") return 2;\r\n  else if(setting===\"fast\") return 50;\r\n  else if(setting===\"medium\") return 150;\r\n  else if(setting===\"slow\") return 300;\r\n  else if(setting===\"very slow\") return 400;\r\n}","export const algorithmOptions = [\r\n    'A* Search', 'Dijkstra', 'Depth-First Search', 'Breadth-First Search', 'Best-First Search', 'Bidirectional search'\r\n];\r\nexport const directionOptions = [\r\n    '4-Directional', '8-Directional'\r\n]\r\nexport const mazeOptions = [\r\n    'Loop', 'Maze 1', 'Maze 2', 'Boxed','Small Boxed'\r\n]\r\nexport const speedOptions = [\r\n    'Very Slow', 'Slow', 'Medium', 'Fast','Very Fast'\r\n]","export default __webpack_public_path__ + \"static/media/bomb.be1672a5.svg\";","import React, { useState, useEffect } from 'react';\n\nimport './CSS/grid.css';\nimport Node from './Components/Node';\nimport { a_star_search } from './algorithms/a_star_search';\nimport { dijkstra_algorithm } from './algorithms/dijkstra';\nimport { bfs } from './algorithms/breadth_first';\nimport { dfs } from './algorithms/depth_first';\nimport { best_first } from './algorithms/best_first';\nimport { bidirectional } from './algorithms/bidirectional_search';\nimport { timeout, findPathFromClosed, drawPath, findPathBidirectional, createBombVisit } from './Helpers/path_finder';\nimport Dropdown from './Components/Dropdown';\nimport { makeMaze } from './Helpers/maze_creation';\nimport ColourCode from './Components/ColourCode';\nimport Results from './Components/Results';\nimport { clear_old_path, clear_visited_path, clearWalls, emptyGrid, setBomb, removeBomb,speedSetter} from './Helpers/gridMethods';\nimport { algorithmOptions, directionOptions, mazeOptions, speedOptions } from './Components/dropdownOptions';\nimport bombSVG from './CSS/bomb.svg';\n\n\nfunction App() {\n  // main grid, start & end points\n  const [Grid, setGrid] = useState([]);\n  const [startLoc, setStartLoc] = useState([5, 5]);\n  const [endLoc, setEndLoc] = useState([5, 15]);\n  // variables for dragging and dropping\n  const [MouseDown, setMouseDown] = useState(false);\n  const [bombDrag, setBombDrag] = useState(false);\n  const [startDrag, setStartDrag] = useState(false);\n  const [endDrag, setEndDrag] = useState(false);\n  //variables for algorithm execution\n  const [isRunning, setRunning] = useState(false);\n  const [speed,setSpeed]=useState(2);\n\n  const [gridPath, setPath] = useState([]);\n  const [visitedPath, setVisited] = useState([]);\n  const [chosenAlgorithm, setAlgorithm] = useState(\"\");\n  const [chosenDirection, setDirection] = useState(\"\");\n  const [startTime, setStartTime] = useState(0);\n  // bomb node\n  const [bombLoc, setBombLoc] = useState([1]);\n\n\n\n  useEffect(() => {\n\n    setGrid(createGrid());\n  }, []);\n\n  const ROWS = 18;\n  const COLS = 55;\n\n  const createGrid = () => {\n    let grid = [];\n    for (let y = 0; y < ROWS; y++) {\n      grid.push([]);\n      for (let x = 0; x < COLS; x++) {\n        grid[y].push(\n          <Node />\n        );\n      }\n    }\n    grid[startLoc[0]][startLoc[1]] = <Node isStart={true} />;\n    grid[endLoc[0]][endLoc[1]] = <Node isEnd={true} />;\n    if (bombLoc.length > 0) grid[bombLoc[0]][bombLoc[1]] = <Node isBomb={true} />;\n\n    return grid;\n  }\n\n\n  const handleMouseDown = (x, y) => {\n    setMouseDown(true);\n    if (x === null || y === null || x < 0 || y < 0) return;\n    // console.log(\"mouse down at\", x, \",\", y);\n\n    console.log(\"start drag-------------x,y=\", x, \",\", y);\n    if (x === startLoc[0] && y === startLoc[1]) {\n      setStartDrag(true);\n    }\n    else if (x === endLoc[0] && y === endLoc[1]) {\n      setEndDrag(true);\n    }\n    else if (x === bombLoc[0] && y === bombLoc[1]) {\n      setBombDrag(true);\n    }\n    else {\n      let newGrid = Grid.slice();\n      if (newGrid[x][y].props.isStart || newGrid[x][y].props.isEnd || newGrid[x][y].props.isBomb) return;\n      newGrid[x][y] =\n        <Node\n          key={y}\n          isWall={!newGrid[x][y].props.isWall} />\n      setGrid(newGrid)\n    }\n  }\n\n  //if moving start or end we want to retain previous wall position\n  const handleMouseEnter = (x, y) => {\n    if (x === null || y === null || x < 0 || y < 0) return;\n    if (x === bombLoc[0] && y === bombLoc[1]) return;\n    if (x === endLoc[0] && y === endLoc[1]) return;\n    if (x === startLoc[0] && y === startLoc[1]) return;\n    if (MouseDown) {\n      let newGrid = Grid.slice();\n      if (!startDrag && !endDrag && !bombDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            isWall={!newGrid[x][y].props.isWall} />\n      }\n      if (startDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            isStart={true}\n            isWall={newGrid[x][y].props.isWall} />\n\n        newGrid[startLoc[0]][startLoc[1]] = <Node\n          isWall={newGrid[startLoc[0]][startLoc[1]].props.isWall}\n        />;\n        setStartLoc([x, y])\n      }\n      else if (endDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            isEnd={true}\n            isWall={newGrid[x][y].props.isWall}\n\n          />\n        newGrid[endLoc[0]][endLoc[1]] = <Node\n          isWall={newGrid[endLoc[0]][endLoc[1]].props.isWall}\n\n        />;\n        console.log(\"set wall at endloc=\", endLoc);\n        setEndLoc([x, y])\n\n\n      }\n      else if (bombDrag) {\n        newGrid[x][y] =\n          <Node\n            key={y}\n            isBomb={true}\n            isWall={newGrid[x][y].props.isWall}\n          />\n        newGrid[bombLoc[0]][bombLoc[1]] = <Node\n          isWall={newGrid[bombLoc[0]][bombLoc[1]].props.isWall}\n        />;\n        setBombLoc([x, y])\n      }\n      setGrid(newGrid)\n    }\n  }\n\n\n  const handleMouseUp = (x, y) => {\n    setMouseDown(false);\n    if (x === null || y === null || x < 0 || y < 0) return;\n    setStartDrag(false);\n    setEndDrag(false);\n    setBombDrag(false);\n  }\n\n\n\n  const bidirectional_search = async () => {\n    let biOutput = [], intersect;\n    if (bombLoc.length > 1) {\n      const startToBomb = bidirectional(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n      const bombToEnd = bidirectional(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n\n      const firstHalf = startToBomb[0];\n      const firstIntersect = startToBomb[1];\n\n      const secondHalf = bombToEnd[0];\n      const secondHalfIntersect = bombToEnd[1];\n\n      const visitedNodes = firstHalf.concat(secondHalf);\n      stepsBeforeExecution(visitedNodes);\n      await drawPathHelper(visitedNodes, 1, \"visited\");\n\n      const biPathOne = await findPathBidirectional(firstHalf, firstIntersect);\n      const biPathTwo = await findPathBidirectional(secondHalf, secondHalfIntersect);\n\n      const joined = biPathOne.concat(biPathTwo);\n      setPath(joined);\n\n      await drawPathHelper(joined, 1, \"path\");\n\n    }\n    else {\n      biOutput = bidirectional(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n      let closed_nodes = biOutput[0];\n      intersect = biOutput[1];\n\n      console.log(\"bi-biOutput=\", biOutput);\n      stepsBeforeExecution(closed_nodes);\n      await drawPathHelper(closed_nodes, 1, \"visited\");\n      if (intersect === null || intersect === undefined) {\n        setPath(null); //Necessary to trigger re-render of App\n        setPath([]);\n        return;\n      }\n      let biPath = await findPathBidirectional(closed_nodes, intersect);\n      setPath(biPath.slice(0, biPath.length - 1));\n      // console.log(\"Find path from closed=\", biPath);\n      await drawPathHelper(biPath, 1, \"path\");\n    }\n\n\n\n  }\n\n\n  const stepsBeforeExecution = (closed_nodes) => {\n    setGrid(clear_visited_path(visitedPath, Grid));\n    setGrid(clear_old_path(gridPath, Grid));\n    setVisited(closed_nodes);\n  }\n  const stepsAfterExecution = async (closed_nodes) => {\n    await drawPathHelper(closed_nodes, 1, \"visited\");\n    await checkEndLocExists(closed_nodes);\n  }\n  const checkEndLocExists = async (closed_nodes) => {\n    const lastElement = closed_nodes[closed_nodes.length - 1];\n    if (lastElement !== null && lastElement !== undefined && lastElement[0] === endLoc[0] && lastElement[1] === endLoc[1]) {\n      closed_nodes = await findPathFromClosedHelper(closed_nodes);\n      console.log(\"checkEndLocExists finalPath=\", closed_nodes);\n      setPath(closed_nodes);\n\n      await drawPathHelper(closed_nodes, 1, \"path\");\n    }\n    else {\n      setPath(null); //Necessary to trigger re-render of App\n      setPath([]);\n    }\n  }\n\n  const findPathFromClosedHelper = async (closed_nodes) => {\n    let path = await findPathFromClosed(closed_nodes, startLoc);\n    return path;\n  }\n\n  const drawPathHelper = async (path, i, type) => {\n    if (i > 0 && i <= path.length - 1) {\n      let newGrid = await drawPath(Grid, path, i, type)\n      setGrid(newGrid);\n      await timeout(speed);\n      await drawPathHelper(path, i + 1, type);\n    }\n\n\n  }\n\n\n  const startAlgorithm = async () => {\n    if (isRunning || chosenAlgorithm===\"\") return;\n    setRunning(true);\n\n    setStartTime(performance.now());\n    let closed_nodes, secondHalf = [];\n    if (chosenAlgorithm === \"A* Search\") {\n      if (bombLoc.length > 1) {\n        closed_nodes = a_star_search(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n        secondHalf = a_star_search(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n        // closed_nodes=createBombVisit(closed_nodes,secondHalf);\n      }\n      else closed_nodes = a_star_search(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n\n\n    }\n    else if (chosenAlgorithm === \"Dijkstra\") {\n      if (bombLoc.length > 1) {\n        closed_nodes = dijkstra_algorithm(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n        secondHalf = dijkstra_algorithm(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n        // closed_nodes=createBombVisit(closed_nodes,secondHalf);\n      }\n      else closed_nodes = dijkstra_algorithm(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n\n    }\n    else if (chosenAlgorithm === \"Breadth-First Search\") {\n      if (bombLoc.length > 1) {\n        closed_nodes = bfs(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n        secondHalf = bfs(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n\n        // closed_nodes=createBombVisit(closed_nodes,secondHalf);\n      }\n      else closed_nodes = bfs(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n    }\n    else if (chosenAlgorithm === \"Depth-First Search\") {\n      if (bombLoc.length > 1) {\n        closed_nodes = dfs(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n        secondHalf = dfs(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n        // closed_nodes=createBombVisit(closed_nodes,secondHalf);\n      }\n      else closed_nodes = dfs(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n    }\n    else if (chosenAlgorithm === \"Best-First Search\") {\n      if (bombLoc.length > 1) {\n        closed_nodes = best_first(ROWS, COLS, startLoc, bombLoc, Grid, chosenDirection);\n        secondHalf = best_first(ROWS, COLS, bombLoc, endLoc, Grid, chosenDirection);\n        // closed_nodes=createBombVisit(closed_nodes,secondHalf);\n      }\n      else closed_nodes = best_first(ROWS, COLS, startLoc, endLoc, Grid, chosenDirection);\n    }\n    else if (chosenAlgorithm === \"Bidirectional search\") {\n      await bidirectional_search();\n      setRunning(false);\n      return;\n\n    }\n    console.log(\"closed nodes ******=\", closed_nodes);\n    if (bombLoc.length > 1) {\n      closed_nodes = createBombVisit(closed_nodes, secondHalf);\n    }\n\n    stepsBeforeExecution(closed_nodes);\n    await stepsAfterExecution(closed_nodes);\n    setRunning(false)\n\n  }\n\n\n  const createWalls = (value) => {\n    setGrid(makeMaze(startLoc, endLoc, emptyGrid(Grid, ROWS, COLS), value));\n  }\n\n\n  const give2dArray = () => {\n    let arr = [];\n    console.log(\"grid=\", Grid[0][1]);\n    for (let i = 0; i < Grid.length; i++) {\n      arr.push([]);\n      for (let j = 0; j < Grid[i].length; j++) {\n        if (Grid[i][j].props.isWall === true) {\n          arr[i].push(1);\n        }\n        else {\n          arr[i].push(0);\n        }\n      }\n      // arr.push(subArr);\n    }\n    console.log(\"arr=\", arr);\n  }\n\n\n\n\n  return (\n    <div className=\"App\">\n      <div className=\"buttonGroup\">\n\n\n        <Dropdown options={algorithmOptions} default={\"Search Algorithm\"}\n          dropDownValueChanged={(value) => setAlgorithm(value)}\n        />\n        {isRunning && (\n          <button className=\"startButton running\">Running {!isRunning && chosenAlgorithm}</button>\n        )}\n        {!isRunning && (\n          <button className=\"startButton\" onClick={async () => await startAlgorithm()}>Start {chosenAlgorithm}</button>\n        )}\n        <button className=\"button\" onClick={() => setGrid(clearWalls(Grid, ROWS, COLS))}>Clear Walls</button>\n        <Dropdown options={directionOptions} default={\"8-Directional\"}\n          dropDownValueChanged={(value) => setDirection(value)}\n        />\n        <Dropdown options={mazeOptions} default={\"Select Maze\"}\n          dropDownValueChanged={(value) => createWalls(value)}\n        />\n        {bombLoc.length > 1 && (\n          <button className=\"button\" onClick={() => { if (bombLoc.length !== 1) { setGrid(removeBomb(Grid, bombLoc[0], bombLoc[1])); setBombLoc([6]); } }}> <img src={bombSVG} alt=\"Bomb Logo\" />REMOVE Bomb</button>\n        )}\n        {bombLoc.length === 1 && (\n          <button className=\"button\" onClick={() => { if (bombLoc.length === 1) { setBombLoc([6, 6]); setGrid(setBomb(Grid, 6, 6)) } }}> <img src={bombSVG} alt=\"Bomb Logo\" />Add Bomb</button>\n        )}\n        <Dropdown options={speedOptions} default={\"very fast\"}\n          dropDownValueChanged={(value) => setSpeed(speedSetter(value))}\n        />\n        <button className=\"button\" onClick={() => give2dArray()}>Give 2d Arr</button>\n      </div>\n\n      <div className=\"container\">\n        {Grid.map((row, yIndex) => {\n          return (\n            <div key={yIndex} className={\"row\"}>\n              {row.map((node, xIndex) => {\n                return (\n                  <Node\n                    key={xIndex}\n                    isBomb={node.props.isBomb}\n                    isWall={node.props.isWall}\n                    isEnd={node.props.isEnd}\n                    isPath={node.props.isPath}\n                    isVisited={node.props.isVisited}\n                    isStart={node.props.isStart}\n                    handleMouseDown={() => handleMouseDown(yIndex, xIndex)}\n                    handleMouseEnter={() => handleMouseEnter(yIndex, xIndex)}\n                    handleMouseUp={() => handleMouseUp(yIndex, xIndex)}\n                  />\n                )\n\n              })}\n            </div>\n          )\n        })}\n        <div className={\"bottomContainer\"}>\n\n          <Results chosenAlgorithm={chosenAlgorithm} startTime={startTime} content={gridPath} expanded={visitedPath} />\n          <ColourCode />\n        </div>\n\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}